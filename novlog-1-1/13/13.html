
<meta charset="utf-8">
<html lang="ko">
<head>
    <link rel="stylesheet" type="text/css" href="./../style.css" />
    <title>[C++ STL] Pair Container 사용법 정리 (With Vector, Typedef, Sort)</title>
</head>
<body id="tt-body-page" class="">
<div id="wrap" class="wrap-right">
    <div id="container">
        <main class="main ">
            <div class="area-main">
                <div class="area-view">
                    <div class="article-header">
                        <div class="inner-article-header">
                            <div class="box-meta">
                                <h2 class="title-article">[C++ STL] Pair Container 사용법 정리 (With Vector, Typedef, Sort)</h2>
                                <div class="box-info">
                                    <p class="category">? Archive/C&C++</p>
                                    <p class="date">2021-05-03 12:56:14</p>
                                </div>
                            </div>
                        </div>
                    </div>
                    <hr>
                    <div class="article-view">
                        <div class="contents_style">
                            <hr contenteditable="false" data-ke-type="horizontalRule" data-ke-style="style5" />
<p><figure class="imageblock alignCenter" data-origin-width="0" data-origin-height="0" data-ke-mobilestyle="widthContent">
    <span data-lightbox="lightbox">
        <img src="./img/img.png" data-origin-width="0" data-origin-height="0" data-ke-mobilestyle="widthContent" />
    </span>
    <figcaption></figcaption>
</figure></p>
<p data-ke-size="size18"><span style="font-family: 'Nanum Gothic'; color: #000000;">#1 Pair 정의 &amp; 사용방법</span></p>
<p data-ke-size="size18"><span style="font-family: 'Nanum Gothic'; color: #000000;">#2 Pair 멤버함수</span></p>
<p><span style="font-family: 'Nanum Gothic'; color: #000000;">- p.first</span></p>
<p><span style="font-family: 'Nanum Gothic'; color: #000000;">- p.second </span></p>
<p><span style="font-family: 'Nanum Gothic'; color: #000000;">- make_pair(v1,v2)</span></p>
<p data-ke-size="size18"><span style="font-family: 'Nanum Gothic'; color: #000000;">#3 Pair 사용예제</span></p>
<p><span style="font-family: 'Nanum Gothic'; color: #000000;">- Pair &amp; vector</span></p>
<p><span style="font-family: 'Nanum Gothic'; color: #000000;"><span style="color: #000000;">- Pair &amp; typedef</span></span></p>
<p><span style="font-family: 'Nanum Gothic'; color: #000000;">- Pair &amp; sort (first 기준 정렬, second 기준 정렬)</span></p>
<p>&nbsp;</p>
<p><span style="font-family: 'Nanum Gothic'; color: #000000;">다음 글은 개인적인 공부내용을 정리하기 위해 작성된 것으로 잘못된 내용이 있을 수 있습니다. :)</span></p>
<p><span style="font-family: 'Nanum Gothic'; color: #000000;">추가하거나 잘못된 내용이 있다면 지속적으로 수정해 나갈 예정입니다.</span></p>
<p><span style="font-family: 'Nanum Gothic'; color: #000000;">벡터 컨테이너에 대한 이해가 부족하시다면 다음 포스팅을 읽고 와주세요. <a href="https://novlog.tistory.com/4" target="_blank" rel="noopener">VECTOR</a></span></p>
<hr contenteditable="false" data-ke-type="horizontalRule" data-ke-style="style5" />
<h2 data-ke-size="size26"><span style="font-family: 'Nanum Gothic'; color: #000000;">#1 Pair 정의 &amp; 사용방법</span><span style="font-family: 'Nanum Gothic'; color: #000000;"></span></h2>
<p data-ke-size="size18"><span style="color: #000000;"><b><span style="font-family: 'Nanum Gothic';">■ Pair 정의</span></b></span></p>
<p><span style="font-family: 'Nanum Gothic'; color: #000000;">Pair는 두개의 객체(first, second)를 하나로 묶어주는 역할을 하는 struct로 데이터의 쌍을 표현할 때 사용한다.</span></p>
<p><span style="font-family: 'Nanum Gothic'; color: #000000;">주로 벡터와 묶어 이차원 배열처럼 사용하거나, 좌표계를 표현할 때 사용되곤 한다.</span></p>
<p>&nbsp;</p>
<p data-ke-size="size18"><span style="color: #000000;"><b><span style="font-family: 'Nanum Gothic';">■ Pair 사용방법</span></b></span></p>
<p><span style="font-family: 'Nanum Gothic'; color: #000000;"><span style="background-color: #333333; color: #ffffff;">① #include &lt;utility&gt;</span> - 유틸리티 헤더를 선언 한다.</span></p>
<p><span style="font-family: 'Nanum Gothic'; color: #000000;"><span style="background-color: #333333; color: #ffffff;">② pair&lt;[type first], [type second]&gt; p_name</span> - 사용할 데이터타입 두 가지를 넣어 주고, pair의 이름을 선언한다.</span></p>
<p><span style="font-family: 'Nanum Gothic'; color: #000000;">pair는 <span style="background-color: #666666; color: #ffffff;">초기에 따로 초기화하지 않으며, make_pair 멤버함수를 사용해 필요할 때 마다 원소를 넣어주는 방식으로 사용한다.</span></span></p>
<p>&nbsp;</p>
<h2 data-ke-size="size26"><span style="font-family: 'Nanum Gothic'; color: #000000;">#2 Pair 멤버함수</span></h2>
<p><span style="font-family: 'Nanum Gothic'; color: #000000;"><span style="background-color: #333333;"><span style="color: #ffffff;">①</span> <span style="color: #ffffff;">p.first</span></span> - p의 첫 번째 인자를 반환한다.</span></p>
<p><span style="font-family: 'Nanum Gothic'; color: #000000;"><span style="background-color: #333333;"><span style="color: #ffffff;">② p.second</span></span> - p의 두 번째 인자를 반환한다.</span></p>
<p><span style="font-family: 'Nanum Gothic'; color: #000000;"><span style="background-color: #333333; color: #ffffff;">③ make_pair(value1, value2)</span> - value1, value2를 가진 pair를 생성한다.</span></p>
<p><b><span style="font-family: 'Nanum Gothic'; color: #000000;">* operator (==, !=, &lt; , &lt;= , &gt;, &gt;=) 를 통한 비교연산이 가능하다.</span></b><span style="font-family: 'Nanum Gothic';"></span></p>
<p><b><span style="font-family: 'Nanum Gothic'; color: #000000;">* algorithm stl - sort 를 통한 정렬이 가능하다.</span></b></p>
<pre id="code_1620011378396" class="c++ arduino" data-ke-language="c++" data-ke-type="codeblock"><code>#include &lt;iostream&gt;
#include &lt;utility&gt;
using namespace std;

int main()
{
	pair&lt;int,int&gt; p1; // &lt;int,int&gt; 타입 페어 생성  
	p1 = make_pair(10,20); // (10,20) 페어 추가
	cout &lt;&lt; "&lt;int,int&gt; p1 \n";
	cout &lt;&lt; p1.first &lt;&lt; endl; // 첫 번째 원소 (10) 출력
	cout &lt;&lt; p1.second &lt;&lt; endl; // 두 번째 원소 (20) 출력 
	
	cout &lt;&lt; "&lt;int,stirng&gt; p2 \n";
	pair&lt;int,string&gt; p2; // &lt;int,string&gt; 타입 페어 생성
	p2 = make_pair(100,"Hello"); // &lt;100,"Hello") 페어 추가
	cout &lt;&lt; p2.first &lt;&lt; endl; // 첫 번째 원소 (100) 출력
	cout &lt;&lt; p2.second &lt;&lt; endl; // 두 번째 원소 ("Hello") 출력 
	return 0;
}</code></pre>
<pre id="code_1620011413906" class="c++ arduino" data-ke-language="c++" data-ke-type="codeblock"><code>[출력결과]
&lt;int,int&gt; p1
10
20
&lt;int,stirng&gt; p2
100
Hello</code></pre>
<p data-ke-size="size16">&nbsp;</p>
<h2 data-ke-size="size26"><span style="font-family: 'Nanum Gothic'; color: #000000;">#3 Pair 사용예제</span></h2>
<p data-ke-size="size18"><b><span style="font-family: 'Nanum Gothic'; color: #000000;">■ pair &amp; vector</span></b></p>
<p><span style="font-family: 'Nanum Gothic'; color: #000000;">pair와 vector 컨테이너를 같이 사용한 예제이다.</span></p>
<pre id="code_1620012414883" class="c++ arduino" data-ke-language="c++" data-ke-type="codeblock"><code>#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;utility&gt;
using namespace std;

int main()
{
	vector&lt;pair&lt;int,int&gt;&gt; v;
	
	v.push_back(make_pair(10,20));
	v.push_back(make_pair(30,40));
	v.push_back(make_pair(50,60));
	
	cout &lt;&lt; v[0].first &lt;&lt; " " &lt;&lt; v[0].second &lt;&lt; endl;
	cout &lt;&lt; v[1].first &lt;&lt; " " &lt;&lt; v[1].second &lt;&lt; endl;
	cout &lt;&lt; v[2].first &lt;&lt; " " &lt;&lt; v[2].second &lt;&lt; endl;
	return 0;
}</code></pre>
<pre id="code_1620012465890" class="c++ arduino" data-ke-language="c++" data-ke-type="codeblock"><code>[출력결과]
10 20
30 40
50 60</code></pre>
<p>&nbsp;</p>
<p data-ke-size="size18"><b><span style="font-family: 'Nanum Gothic'; color: #000000;">■ pair &amp; typedef</span></b></p>
<p><span style="font-family: 'Nanum Gothic'; color: #000000;">typedef 문법을 이용해서, pair를 간략하게 표현 가능하다.</span></p>
<p><span style="font-family: 'Nanum Gothic'; color: #000000;">앞의 vector 예제에서 pair 부분만 typedef로 바꾸어 선언한 예제이다. (출력 결과는 동일하다.)</span></p>
<pre id="code_1620012593485" class="c++ arduino" data-ke-language="c++" data-ke-type="codeblock"><code>#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;utility&gt;
using namespace std;

typedef pair&lt;int,int&gt; P; // typedef pair

int main()
{
	vector&lt;P&gt; v;
	
	v.push_back(make_pair(10,20));
	v.push_back(make_pair(30,40));
	v.push_back(make_pair(50,60));
	
	cout &lt;&lt; v[0].first &lt;&lt; " " &lt;&lt; v[0].second &lt;&lt; endl;
	cout &lt;&lt; v[1].first &lt;&lt; " " &lt;&lt; v[1].second &lt;&lt; endl;
	cout &lt;&lt; v[2].first &lt;&lt; " " &lt;&lt; v[2].second &lt;&lt; endl;
	return 0;
}</code></pre>
<p>&nbsp;</p>
<p data-ke-size="size18"><b><span style="font-family: 'Nanum Gothic'; color: #000000;">■ pair &amp; sort</span></b></p>
<p><span style="font-family: 'Nanum Gothic'; color: #000000;">pair는 algorithm의 sort를 이용해 정렬이 가능하다. sort의 세 번째 인덱스를 따로 지정해 주지 않으면, first 를 기준으로 정렬하고 비교함수를 구현해서 second 기준으로 정렬하는 것도 가능하다.</span><span style="font-family: 'Nanum Gothic'; color: #000000;"></span></p>
<p>&nbsp;</p>
<p data-ke-size="size18"><span style="font-family: 'Nanum Gothic'; color: #ffffff; background-color: #333333;">- first 기준 정렬</span></p>
<pre id="code_1620013013119" class="c++ arduino" data-ke-language="c++" data-ke-type="codeblock"><code>#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;utility&gt;
using namespace std;

typedef pair&lt;int,int&gt; P;

int main()
{
	vector&lt;P&gt; v;
	v.push_back(make_pair(10,20));
	v.push_back(make_pair(50,40));
	v.push_back(make_pair(30,60));
	
	cout &lt;&lt; "[Before Sort]" &lt;&lt; endl; 
	cout &lt;&lt; v[0].first &lt;&lt; " " &lt;&lt; v[0].second &lt;&lt; endl;
	cout &lt;&lt; v[1].first &lt;&lt; " " &lt;&lt; v[1].second &lt;&lt; endl;
	cout &lt;&lt; v[2].first &lt;&lt; " " &lt;&lt; v[2].second &lt;&lt; endl;
	
	sort(v.begin(), v.end()); // first 기준 정렬
	
	cout &lt;&lt; "[After Sort] First 기준 정렬" &lt;&lt; endl; 
	cout &lt;&lt; v[0].first &lt;&lt; " " &lt;&lt; v[0].second &lt;&lt; endl;
	cout &lt;&lt; v[1].first &lt;&lt; " " &lt;&lt; v[1].second &lt;&lt; endl;
	cout &lt;&lt; v[2].first &lt;&lt; " " &lt;&lt; v[2].second &lt;&lt; endl;
	return 0;
}</code></pre>
<pre id="code_1620013027183" class="c++ arduino" data-ke-language="c++" data-ke-type="codeblock"><code>[Before Sort]
10 20
50 40
30 60
[After Sort] First 기준 정렬
10 20
30 60
50 40</code></pre>
<p>&nbsp;</p>
<p data-ke-size="size18"><span style="font-family: 'Nanum Gothic'; color: #ffffff; background-color: #333333;">- second 기준 정렬</span></p>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;">내림차순 정렬은, compare 함수에서 부등호 방향을 반대로 바꿔주면 된다.</span></p>
<pre id="code_1620013870685" class="c++ arduino" data-ke-language="c++" data-ke-type="codeblock"><code>#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;utility&gt;
using namespace std;

typedef pair&lt;int,int&gt; P;

bool compare(P x, P y)
{
	return x.second &lt; y.second;
}
 
int main()
{
	vector&lt;P&gt; v;
	v.push_back(make_pair(10,20));
	v.push_back(make_pair(50,10));
	v.push_back(make_pair(30,60));
	
	cout &lt;&lt; "[Before Sort]" &lt;&lt; endl; 
	cout &lt;&lt; v[0].first &lt;&lt; " " &lt;&lt; v[0].second &lt;&lt; endl;
	cout &lt;&lt; v[1].first &lt;&lt; " " &lt;&lt; v[1].second &lt;&lt; endl;
	cout &lt;&lt; v[2].first &lt;&lt; " " &lt;&lt; v[2].second &lt;&lt; endl;
	
	sort(v.begin(), v.end(), compare);
	
	cout &lt;&lt; "[After Sort] Second 기준 정렬" &lt;&lt; endl; 
	cout &lt;&lt; v[0].first &lt;&lt; " " &lt;&lt; v[0].second &lt;&lt; endl;
	cout &lt;&lt; v[1].first &lt;&lt; " " &lt;&lt; v[1].second &lt;&lt; endl;
	cout &lt;&lt; v[2].first &lt;&lt; " " &lt;&lt; v[2].second &lt;&lt; endl;
	return 0;
}</code></pre>
<pre id="code_1620013931889" class="c++ arduino" data-ke-language="c++" data-ke-type="codeblock"><code>[Before Sort]
10 20
50 10
30 60
[After Sort] Second 기준 정렬
50 10
10 20
30 60</code></pre>
                        </div>
                        <br/>
                        <div class="tags">
                            #C++ #STL #컨테이너 #정렬 #sort #Pair #typedef #first기준 #second기준 
                        </div>
                    </div>
                </div>
            </div>
        </main>
    </div>
</div>
</body>
</html>
