
<meta charset="utf-8">
<html lang="ko">
<head>
    <link rel="stylesheet" type="text/css" href="./../style.css" />
    <title>[BOJ] 11053 "가장 긴 증가하는 부분 수열" 문제 풀이 & 소스 코드 with C/C++</title>
</head>
<body id="tt-body-page" class="">
<div id="wrap" class="wrap-right">
    <div id="container">
        <main class="main ">
            <div class="area-main">
                <div class="area-view">
                    <div class="article-header">
                        <div class="inner-article-header">
                            <div class="box-meta">
                                <h2 class="title-article">[BOJ] 11053 "가장 긴 증가하는 부분 수열" 문제 풀이 & 소스 코드 with C/C++</h2>
                                <div class="box-info">
                                    <p class="category">? Archive/ProblemSolving</p>
                                    <p class="date">2021-08-18 14:15:05</p>
                                </div>
                            </div>
                        </div>
                    </div>
                    <hr>
                    <div class="article-view">
                        <div class="contents_style">
                            <h2 data-ke-size="size26"><span style="font-family: 'Noto Serif KR'; color: #000000;">#INFO</span></h2>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;">난이도 : <span style="background-color: #dddddd;">SILVER2</span></span></p>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;">알고리즘 유형 : <span style="background-color: #333333; color: #ffffff;">DP(다이나믹 프로그래밍)</span></span></p>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;">문제 출처 :</span> <a href="https://www.acmicpc.net/problem/11053" target="_blank" rel="noopener">https://www.acmicpc.net/problem/11053</a></p>
<p><figure class="imageblock alignLeft" data-origin-width="1574" data-origin-height="785" data-ke-mobilestyle="widthOrigin">
    <span data-lightbox="lightbox">
        <img src="./img/img.png" data-origin-width="1574" data-origin-height="785" data-ke-mobilestyle="widthOrigin" />
    </span>
    <figcaption></figcaption>
</figure></p>
<hr contenteditable="false" data-ke-type="horizontalRule" data-ke-style="style5" />
<h2 data-ke-size="size26"><span style="font-family: 'Noto Serif KR'; color: #000000;">#SOLVE</span></h2>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;">11053 "가장 긴 증가하는 부분 수열" 문제 풀이를 위해 2가지 배열을 선언했다.</span></p>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;"><span style="background-color: #333333; color: #ffffff;">1. ary[1001]</span> - 수열의 원소를 저장할 배열이다.</span></p>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;"><span style="background-color: #333333; color: #ffffff;">2. dp[1001]</span> - 각 원소로 끝나는 가장 긴 부분 수열을 저장할 배열이다. <b>(예를 들어 dp[2] = 3 은 , 2번째 인덱스의 원소로 끝나는 가장 긴 부분 수열의 길이가 3 이라는 의미이다.)</b></span></p>
<pre id="code_1629261542825" class="c++ arduino" data-ke-language="c++" data-ke-type="codeblock"><code>int ary[1001];
int dp[1001];</code></pre>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;">다음으로 dp 배열의 모든 원소를 fill_n 메서드를 이용해 1로 초기화 한다. 왜냐하면 각 원소 그 자체로 하나의 부분 수열이기 때문이다.&nbsp;</span></p>
<pre id="code_1629261779261" class="c++ arduino" data-ke-language="c++" data-ke-type="codeblock"><code>	// Initialize dp array with "1"
	fill_n(dp, n+1, 1);</code></pre>
<p><figure class="imageblock alignLeft" data-origin-width="561" data-origin-height="228" data-ke-mobilestyle="widthOrigin">
    <span data-lightbox="lightbox">
        <img src="./img/img_1.png" data-origin-width="561" data-origin-height="228" data-ke-mobilestyle="widthOrigin" />
    </span>
    <figcaption></figcaption>
</figure></p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;">이제 각 원소들의 dp값 (각 원소로 끝나는 가장 긴 부분 수열의 길이) 를 구해 보자.</span></p>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;">가장 긴 부분 수열을 만들기 위해서는 <u><b>다음 2가지 조건을 충족해야 한다.</b></u></span></p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size18"><span style="font-family: 'Nanum Gothic'; color: #ffffff; background-color: #333333;">1. 현재 인덱스의 값이 비교하는 인덱스의 값 보다 커야 한다.</span></p>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;">예를 들어 <span style="background-color: #333333; color: #ffffff;">5번째 인덱스의 값 (20) 의 dp값을 구한다고 생각해 보자.</span> 현재 인덱스 값 ( 5번째 인덱스 값 20) 이 비교 인덱스 값 ( 1번째 인덱스 10 ) 보다 크기에 <b><span style="color: #006dd7;">증가 부분 수열의 조건을 만족</span></b>한다.</span></p>
<p><figure class="imageblock alignLeft" data-origin-width="561" data-origin-height="228" data-ke-mobilestyle="widthOrigin">
    <span data-lightbox="lightbox">
        <img src="./img/img_2.png" data-origin-width="561" data-origin-height="228" data-ke-mobilestyle="widthOrigin" />
    </span>
    <figcaption></figcaption>
</figure></p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;">이번에는 <span style="background-color: #333333; color: #ffffff;">5번째 인덱스 값 (20) 과 2번째 인덱스 (20) 을 비교</span>해보자. 현재 인덱스 값 ( 5번째 인덱스 값 20 ) 이 비교 인덱스 값 ( 2번째 인덱스 값 20 ) 보다 크지 않기에 , <b><span style="color: #ee2323;">증가 부분 수열의 조건을 만족하지 못한다.</span></b></span></p>
<p><figure class="imageblock alignLeft" data-origin-width="561" data-origin-height="228" data-ke-mobilestyle="widthOrigin">
    <span data-lightbox="lightbox">
        <img src="./img/img_3.png" data-origin-width="561" data-origin-height="228" data-ke-mobilestyle="widthOrigin" />
    </span>
    <figcaption></figcaption>
</figure></p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size18"><span style="font-family: 'Nanum Gothic'; color: #ffffff; background-color: #333333;">2. 비교 인덱스 값을 증가 부분 수열에 추가 하는 것이 최적의 선택이 되어야 한다.</span></p>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;">말로만 들으면 모호할 수 있으니, 4번째 인덱스의 dp값을 구하는 상황을 예시로 이해해 보도록 하자.<u><b> (1, 2, 3 번째 인덱스의 dp값은 미리 알맞은 dp값으로 초기화해 두었다고 가정한다)</b></u></span></p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;"><span style="background-color: #333333; color: #ffffff;">4번째 인덱스 값 (30) 과 1번째 인덱스 값 (10) 을 비교</span>한다. 4번째 인덱스 값 (30) 이 1번째 인덱스 값 (10) 보다 크기에, <b><span style="color: #006dd7;">1번조건은 만족한다.</span></b> 다음으로 2번조건을 살펴보자.</span></p>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;">현재 4번째 인덱스의 증가 부분수열은 {30} 이다. 여기에 1번째 인덱스 값 (10) 을 추가하면 {10, 30} 이 된다. 따라서 <b><span style="color: #006dd7;">1번째 인덱스를 증가 부분 수열에 추가하는 것이 최적의 선택이다.</span> 모든 조건을 만족하니, dp (증가 부분 수열의 길이) 를 1 증가 시킨다.</b></span></p>
<p><figure class="imageblock alignLeft" data-origin-width="561" data-origin-height="228" data-ke-mobilestyle="widthOrigin">
    <span data-lightbox="lightbox">
        <img src="./img/img_4.png" data-origin-width="561" data-origin-height="228" data-ke-mobilestyle="widthOrigin" />
    </span>
    <figcaption></figcaption>
</figure><figure class="imageblock alignLeft" data-origin-width="561" data-origin-height="228" data-ke-mobilestyle="widthOrigin">
    <span data-lightbox="lightbox">
        <img src="./img/img_5.png" data-origin-width="561" data-origin-height="228" data-ke-mobilestyle="widthOrigin" />
    </span>
    <figcaption></figcaption>
</figure></p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;"><span style="background-color: #333333; color: #ffffff;">4번째 인덱스 값 (30) 과 2번째 인덱스 값 (20) 을 비교</span>한다. 마찬가지로 4번째 인덱스 값 (30) 이 2번째 인덱스 값 (20) 보다 크기에, <b><span style="color: #006dd7;">1번 조건을 만족</span></b>한다.&nbsp;</span></p>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;">현재 4번째 인덱스의 증가 부분 수열은 {10, 30} 이다. 여기에 2번째 인덱스 값 (20) 을 추가하면, {10, 20, 30} 이 된다. 따라서 <b><span style="color: #006dd7;">2번째 인덱스를 증가 부분 수열에 추가하는 것이 최적의 선택이다.&nbsp;</span></b></span></p>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;">마찬가지로 모든 조건을 만족하기에, <b>dp값을 1 증가</b>시킨다.</span></p>
<p><figure class="imageblock alignLeft" data-origin-width="561" data-origin-height="228" data-ke-mobilestyle="widthOrigin">
    <span data-lightbox="lightbox">
        <img src="./img/img_6.png" data-origin-width="561" data-origin-height="228" data-ke-mobilestyle="widthOrigin" />
    </span>
    <figcaption></figcaption>
</figure><figure class="imageblock alignLeft" data-origin-width="561" data-origin-height="228" data-ke-mobilestyle="widthOrigin">
    <span data-lightbox="lightbox">
        <img src="./img/img_7.png" data-origin-width="561" data-origin-height="228" data-ke-mobilestyle="widthOrigin" />
    </span>
    <figcaption></figcaption>
</figure></p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;">마지막으로 <span style="background-color: #333333; color: #ffffff;">4번째 인덱스 값 (30) 과 3번째 인덱스 값 (10) 을 비교</span>해 보자. 우선, <b><span style="color: #006dd7;">1번째 조건은 만족</span></b>한다.&nbsp;</span></p>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;">다음으로 2번째 조건을 만족하는 지 확인해 보자. 현재 4번째 인덱스의 증가 부분 수열은 {10, 20, 30} 이다. 그런데 여기서 3번째 인덱스 값을 증가 부분 수열에 추가하면 {10, 30} 으로 오히려 증가 부분 수열의 길이가 3에서 2로 줄어든다. <b><span style="color: #ee2323;">따라서 3번째 인덱스 값을 증가 부분 수열에 추가하는 것은 최적의 선택이 아니다.</span></b></span></p>
<p><figure class="imageblock alignLeft" data-origin-width="561" data-origin-height="228" data-ke-mobilestyle="widthOrigin">
    <span data-lightbox="lightbox">
        <img src="./img/img_8.png" data-origin-width="561" data-origin-height="228" data-ke-mobilestyle="widthOrigin" />
    </span>
    <figcaption></figcaption>
</figure></p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;">설명이 길어졌는데, 코드는 그렇게 어렵지 않다.</span></p>
<pre id="code_1629263333088" class="c++ arduino" data-ke-language="c++" data-ke-type="codeblock"><code>	for (int i = 1 ; i &lt;= n ; ++i) {
		for (int j = 1 ; j &lt;= i ; ++j) {
			if (ary[j] &lt; ary[i] &amp;&amp; dp[i] &lt; dp[j] + 1)
			dp[i] = dp[j] + 1;
		}
	}</code></pre>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;">마지막으로 dp 배열에 저장된 원소들 중 가장 큰 값을 출력해 주기만 하면 된다.</span></p>
<pre id="code_1629263365793" class="c++ arduino" data-ke-language="c++" data-ke-type="codeblock"><code>cout &lt;&lt; *max_element(dp, dp + sizeof(dp)/sizeof(int)) &lt;&lt; "\n";</code></pre>
<hr contenteditable="false" data-ke-type="horizontalRule" data-ke-style="style5" />
<h2 data-ke-size="size26"><span style="font-family: 'Noto Serif KR'; color: #000000;">#CODE</span></h2>
<pre id="code_1629263385516" class="c++ arduino" data-ke-language="c++" data-ke-type="codeblock"><code>#include &lt;iostream&gt;
#include &lt;algorithm&gt;
using namespace std;
int ary[1001];
int dp[1001];

int main() {
	int n;
	cin &gt;&gt; n;
	// Initialize dp array with "1"
	fill_n(dp, n+1, 1);
	
	for (int i = 1 ; i &lt;= n ; ++i) {
		cin &gt;&gt; ary[i];
	}
	
	for (int i = 1 ; i &lt;= n ; ++i) {
		for (int j = 1 ; j &lt;= i ; ++j) {
			if (ary[j] &lt; ary[i] &amp;&amp; dp[i] &lt; dp[j] + 1)
			dp[i] = dp[j] + 1;
		}
	}
	
	cout &lt;&lt; *max_element(dp, dp + sizeof(dp)/sizeof(int)) &lt;&lt; "\n";
	
	return 0;
}</code></pre>
<p><figure class="imageblock alignCenter" data-origin-width="977" data-origin-height="54" data-ke-mobilestyle="widthOrigin">
    <span data-lightbox="lightbox">
        <img src="./img/img_9.png" data-origin-width="977" data-origin-height="54" data-ke-mobilestyle="widthOrigin" />
    </span>
    <figcaption></figcaption>
</figure></p>
<hr contenteditable="false" data-ke-type="horizontalRule" data-ke-style="style5" />
                        </div>
                        <br/>
                        <div class="tags">
                            #해설 #C++ #알고리즘 #소스코드 #문제풀이 #BOJ #백준 #가장긴증가하는부분수열 #11053 
                        </div>
                    </div>
                </div>
            </div>
        </main>
    </div>
</div>
</body>
</html>
