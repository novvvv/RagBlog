
<meta charset="utf-8">
<html lang="ko">
<head>
    <link rel="stylesheet" type="text/css" href="./../style.css" />
    <title>[C#] 3. 생성자와 this / this() 키워드</title>
</head>
<body id="tt-body-page" class="">
<div id="wrap" class="wrap-right">
    <div id="container">
        <main class="main ">
            <div class="area-main">
                <div class="area-view">
                    <div class="article-header">
                        <div class="inner-article-header">
                            <div class="box-meta">
                                <h2 class="title-article">[C#] 3. 생성자와 this / this() 키워드</h2>
                                <div class="box-info">
                                    <p class="category">? Archive/C#</p>
                                    <p class="date">2021-05-30 19:50:43</p>
                                </div>
                            </div>
                        </div>
                    </div>
                    <hr>
                    <div class="article-view">
                        <div class="contents_style">
                            <p><figure class="imageblock alignLeft" data-origin-width="313" data-origin-height="319" data-filename="c#.png" width="201" height="205" data-ke-mobilestyle="widthOrigin">
    <span data-lightbox="lightbox">
        <img src="./img/img.png" data-origin-width="313" data-origin-height="319" data-filename="c#.png" width="201" height="205" data-ke-mobilestyle="widthOrigin" />
    </span>
    <figcaption></figcaption>
</figure></p>
<p data-ke-size="size18"><span style="font-family: 'Nanum Gothic'; color: #ffffff; background-color: #333333;">#3 생성자와 this / this() 키워드</span></p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;"><b>[학습목표]</b></span></p>
<ul style="list-style-type: disc;" data-ke-list-type="disc">
<li><span style="font-family: 'Nanum Gothic'; color: #000000;">생성자의 개념과 사용방법에 대한 이해</span></li>
<li><span style="font-family: 'Nanum Gothic'; color: #000000;">this 키워드 사용방법 숙지</span></li>
<li><span style="font-family: 'Nanum Gothic'; color: #000000;">this() 키워드 사용방법 숙지</span></li>
</ul>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;"><b><span style="color: #000000;">[목차]</span></b></span></p>
<ul style="list-style-type: disc;" data-ke-list-type="disc">
<li><span style="font-family: 'Nanum Gothic'; color: #000000;">1.1 생성자가 필요한 이유</span></li>
<li><span style="font-family: 'Nanum Gothic'; color: #000000;">1.2 생성자</span></li>
<li><span style="font-family: 'Nanum Gothic'; color: #000000;">2.1 this 키워드</span></li>
<li><span style="font-family: 'Nanum Gothic'; color: #000000;">2.2 this() 키워드</span></li>
</ul>
<p data-ke-size="size16"><b>* 개인적인 공부 기록용으로 작성한 글이기에, 잘못된 내용이 있을 수 있습니다.</b></p>
<hr contenteditable="false" data-ke-type="horizontalRule" data-ke-style="style5" />
<h2 data-ke-size="size26"><b><span style="font-family: 'Nanum Gothic'; color: #000000;">#1.1 생성자가 필요한 이유</span></b></h2>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;">생성자 문법에 대해 알아보기 전에, 우선 생성자가 왜 필요한지에 대해서 알아 보도록 하겠습니다. </span><span style="font-family: 'Nanum Gothic'; color: #000000;">아래 코드를 봐주세요.</span></p>
<pre id="code_1622370087496" class="cs" data-ke-language="cs" data-ke-type="codeblock"><code>namespace TextRpg
{
    class Knight
    {
        public int hp;
        public int atk;

    }

    class Program
    {
        static void Main(string[] args)
        {
            Knight knight = new Knight();
            knight.hp = 100;
            knight.atk = 10;
        }
    }
}</code></pre>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;">Knight 클래스를 정의한 뒤, Main 함수부에서 knight 객체의 멤버함수 hp, atk 값을 각각 초기화 해 주고 있습니다.</span></p>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;">그런데 만약 hp와 atk값을 실수로 초기화 하지 않으면, hp와 atk가 0인 기사 플레이어가 월드에 생성되게 됩니다.</span></p>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;">또한, <span style="background-color: #333333; color: #ffffff;">Main 함수부에서 객체의 모든 값을 초기화 하는 것은 가독성과 유지보수 면에서도 매우 비효율 적입니다.</span></span></p>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;">이러한 상황을 해결하기 위해 C#은 <span style="background-color: #333333; color: #ffffff;">생성자</span>라는 문법을 제공합니다.</span></p>
<p data-ke-size="size16">&nbsp;</p>
<h2 data-ke-size="size26"><b><span style="font-family: 'Nanum Gothic'; color: #000000;">#1.2 생성자</span></b></h2>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #ffffff; background-color: #333333;">생성자를 이용하면 자동으로 객체의 값을 초기화 해 줄 수 있습니다. </span><span style="font-family: 'Nanum Gothic'; color: #000000;">생성자의 사용 방법은 다음과 같습니다.</span></p>
<pre id="code_1622370269815" class="cs" data-ke-language="cs" data-ke-type="codeblock"><code>접근지정자 클래스이름 {}</code></pre>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic';"><span style="background-color: #333333; color: #ffffff;">생성자의 이름은 무조건 클래스의 이름과 동일해야만 합니다.</span> 또한, void / int 와 같은 <span style="background-color: #333333; color: #ffffff;">반환형은 올 수 없습니다.</span></span></p>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic';">아래는 생성자를 사용한 예시입니다.</span></p>
<pre id="code_1622370368213" class="cs" data-ke-language="cs" data-ke-type="codeblock"><code>namespace TextRpg
{
    class Knight
    {
        public int hp;
        public int atk;

        public Knight()
        {
            hp = 100;
            atk = 10;
        }

    }

    class Program
    {
        static void Main(string[] args)
        {
            Knight knight = new Knight();
        }
    }
}</code></pre>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;">이렇게 생성자 문법을 이용하면, 혹여나 객체의 값을 초기화 하지 않았다 하더라도, 자동으로 생성자가 멤버값을 초기화 해 줍니다. 그리고 Main 함수부의 코드도 줄어서 가독성도 좋아졌습니다.</span></p>
<p data-ke-size="size16">&nbsp;</p>
<h2 data-ke-size="size26"><b><span style="font-family: 'Nanum Gothic'; color: #000000;">#2.1 this 키워드</span></b></h2>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;">생성자는 여러개 만들 수 있습니다. hp를 인자로 받는 생성자를 하나 더 만들어 봅시다.</span></p>
<pre id="code_1622370616152" class="cs" data-ke-language="cs" data-ke-type="codeblock"><code>    class Knight
    {
        public int hp;
        public int atk;

        public Knight()
        {
            hp = 100;
            atk = 10;
        }

        public Knight(int hp)
        {
            hp = hp;
        }

    }</code></pre>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;">하지만 다음과 같은 CS1717 에러 메시지가 출력됩니다.</span></p>
<p><figure class="imageblock alignLeft" data-origin-width="580" data-origin-height="141" data-ke-mobilestyle="widthOrigin">
    <span data-lightbox="lightbox">
        <img src="./img/img_1.png" data-origin-width="580" data-origin-height="141" data-ke-mobilestyle="widthOrigin" />
    </span>
    <figcaption></figcaption>
</figure></p>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;">이는 <span style="background-color: #333333; color: #ffffff;">파라미터로 받은 hp와 클래스에 존재하는 hp멤버변수의 이름이 같기 때문에 발생하는 오류</span>입니다. 이 것을 해결하기 위해선 <span style="background-color: #333333; color: #ffffff;">this 키워드를 사용</span>하면 됩니다. <span style="background-color: #333333; color: #ffffff;">this는 클래스에 존재하는 멤버변수를 가리키는 키워드</span>입니다. 다음과 같이 선언해 주면 해결됩니다.</span></p>
<pre id="code_1622370830484" class="cs" data-ke-language="cs" data-ke-type="codeblock"><code>    class Knight
    {
        public int hp;
        public int atk;

        public Knight()
        {
            hp = 100;
            atk = 10;
        }

        public Knight(int hp)
        {
            this.hp = hp;
        }

    }</code></pre>
<p><figure class="imageblock alignLeft" data-origin-width="339" data-origin-height="477" width="231" height="325" data-ke-mobilestyle="widthOrigin">
    <span data-lightbox="lightbox">
        <img src="./img/img_2.png" data-origin-width="339" data-origin-height="477" width="231" height="325" data-ke-mobilestyle="widthOrigin" />
    </span>
    <figcaption></figcaption>
</figure></p>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;">이로써, 클래스에 존재하는 hp와, 파라미터 hp를 구별이 가능하게 됐습니다.</span></p>
<p data-ke-size="size16">&nbsp;</p>
<h2 data-ke-size="size26"><b><span style="font-family: 'Nanum Gothic'; color: #000000;">#2.2 this()</span></b></h2>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;">그런데, 여전히 문제가 있습니다. 만약 두 번째 생성자를 호출 했다면, hp의 값을 채워졌는데 atk의 값은 여전히 채워지지 않았기 때문입니다. 이를 해결하기 위해서 this.atk = atk; 와 같이 선언해 주면 되지만, 멤버변수가 몇십개로 매우 많은 상황이라면 하나하나 작성해 주는 것은 매우 비효율 적일 것입니다.</span></p>
<p data-ke-size="size16"><span style="color: #000000;">여기서 this() 키워드를 사용하면 문제를 해결할 수 있습니다. <span style="background-color: #333333; color: #ffffff; font-family: 'Nanum Gothic';">this() 키워드는 생성자를 특정하여 , 먼저 호출을 해줍니다.</span></span></p>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;"><span style="background-color: #333333; color: #ffffff;">this() 키워드의 사용방법</span>은, <span style="background-color: #333333; color: #ffffff;">생성자 오른쪽에 콜론(:)과 함께 this()를 작성</span>해 주면 됩니다.</span></p>
<pre id="code_1622371284885" class="cs" data-ke-language="cs" data-ke-type="codeblock"><code>namespace TextRpg
{
    class Knight
    {
        public int hp;
        public int atk;

        public Knight()
        {
            hp = 100;
            atk = 10;
            Console.WriteLine("Knight() 호출");
        }

        public Knight(int hp) : this()
        {
            this.hp = hp;
            Console.WriteLine("int Knight() 호출");
        }

    }

    class Program
    {
        static void Main(string[] args)
        {
            Knight knight = new Knight(50);
        }
    }
}</code></pre>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;">코드의 흐름을 그림으로 표현해 보았습니다.</span></p>
<p><figure class="imageblock alignLeft" data-origin-width="473" data-origin-height="623" data-ke-mobilestyle="widthOrigin">
    <span data-lightbox="lightbox">
        <img src="./img/img_3.png" data-origin-width="473" data-origin-height="623" data-ke-mobilestyle="widthOrigin" />
    </span>
    <figcaption></figcaption>
</figure></p>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;">두 번째 생성자가 실행되기 전에, this() 키워드를 만나서, 첫 번째 생성자를 먼저 실행합니다.</span></p>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;">따라서 최종적으로 hp = 50 , atk = 10 인 knight 객체가 생성되게 됩니다.</span></p>
<p data-ke-size="size16">&nbsp;</p>
<p><span style="color: #000000;">물론, 아래 처럼 원하는 생성자를 특정해서 사용하는 것도 가능합니다.&nbsp;</span></p>
<pre id="code_1622378708873" class="cs" data-ke-language="cs" data-ke-type="codeblock"><code>namespace TextRpg
{
    class Knight
    {
        public int hp;
        public int atk;

        public Knight()
        {
            hp = 100;
            atk = 10;
            Console.WriteLine("Knight() 호출");
        }

        public Knight(int hp)
        {
            this.hp = hp;
            Console.WriteLine("int Knight() 호출");
        }

        public Knight(int hp, int atk) : this(hp)
        {
            this.hp = hp;
            this.atk = atk;
            Console.WriteLine("int int Knight() 호출");
        }
    }

    class Program
    {
        static void Main(string[] args)
        {
            Knight knight = new Knight(50,10);
        }
    }
}
</code></pre>
<pre id="code_1622378731152" class="cs" data-ke-language="cs" data-ke-type="codeblock"><code>[출력결과]
int Knight() 호출
int int Knight() 호출</code></pre>
<p><figure class="imageblock alignLeft" data-origin-width="1039" data-origin-height="642" width="782" height="483" data-ke-mobilestyle="widthOrigin">
    <span data-lightbox="lightbox">
        <img src="./img/img_4.png" data-origin-width="1039" data-origin-height="642" width="782" height="483" data-ke-mobilestyle="widthOrigin" />
    </span>
    <figcaption></figcaption>
</figure></p>
                        </div>
                        <br/>
                        <div class="tags">
                            #생성자 #This #c# #객체지향 #this() 
                        </div>
                    </div>
                </div>
            </div>
        </main>
    </div>
</div>
</body>
</html>
