
<meta charset="utf-8">
<html lang="ko">
<head>
    <link rel="stylesheet" type="text/css" href="./../style.css" />
    <title>[Java] 생성자 [Constructor] 및 this() 사용방법</title>
</head>
<body id="tt-body-page" class="">
<div id="wrap" class="wrap-right">
    <div id="container">
        <main class="main ">
            <div class="area-main">
                <div class="area-view">
                    <div class="article-header">
                        <div class="inner-article-header">
                            <div class="box-meta">
                                <h2 class="title-article">[Java] 생성자 [Constructor] 및 this() 사용방법</h2>
                                <div class="box-info">
                                    <p class="category">Back-end/Java Fundamental</p>
                                    <p class="date">2024-02-10 16:27:20</p>
                                </div>
                            </div>
                        </div>
                    </div>
                    <hr>
                    <div class="article-view">
                        <div class="contents_style">
                            <p style="text-align: center;" data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;"><span style="text-align: start;"><span style="background-color: #333333; color: #dddddd;">Constructor 생성자</span>란, <b>객체를 생성과 동시에 초기화 할 수 있도록 도와주는 특별한 메서드</b>이다. 생성자를 사용하지 않고, 생성한 객체에 직접 접근하여 값을 대입해 줄 수도 있지만 생성자를 사용하면 <b>객체에 필요한 입력값을 &ldquo;강제&rdquo;할 수 있다</b>는 장점이 있다.</span><span style="text-align: start;"></span></span></p>
<p style="text-align: center;" data-ke-size="size16"><span style="color: #000000; text-align: start; font-family: 'Nanum Gothic';">이번 포스팅 에서는 생성자의 사용 방법에 대해 정리해 보고자 한다. </span></p>
<p style="text-align: center;" data-ke-size="size16">&nbsp;</p>
<p style="text-align: center;" data-ke-size="size18"><b><span style="color: #000000; text-align: start; font-family: 'Nanum Gothic';">목차</span></b></p>
<p style="text-align: center;" data-ke-size="size18"><b><span style="color: #000000; text-align: start; font-family: 'Nanum Gothic';">#1 Constructor</span></b></p>
<p style="text-align: center;" data-ke-size="size18"><b><span style="color: #000000; text-align: start; font-family: 'Nanum Gothic';">#2 Constructor Overloading &amp; this() keyword</span></b></p>
<p style="text-align: center;" data-ke-size="size16"><span style="color: #000000; text-align: start; font-family: 'Nanum Gothic';">- this() keyword를 사용한 중복 제거</span></p>
<p style="text-align: center;" data-ke-size="size18"><b><span style="color: #000000; text-align: start; font-family: 'Nanum Gothic';">#3 Default Constructor</span></b></p>
<hr contenteditable="false" data-ke-type="horizontalRule" data-ke-style="style5" />
<h2 style="text-align: left;" data-ke-size="size26"><span style="font-family: 'Nanum Gothic'; color: #000000;">#1 Constructor</span></h2>
<p style="text-align: left;" data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;">생성자는 작성하고자 하는 <b>클래스명과 동일하게 작성</b>하며, <b>반환값을 가지지 않는다.</b></span></p>
<pre id="code_1707609716039" class="java" data-ke-language="java" data-ke-type="codeblock"><code>클래스명(매개변수){ ... }</code></pre>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;">인스턴스 호출 부분에서 작성한 매개변수와 함께 생성자를 호출하여 멤버변수를 초기화하면 된다.</span></p>
<pre id="code_1707610047551" class="java" data-ke-language="java" data-ke-type="codeblock"><code>클래스명 객체명 = new 생성자명(매개변수1, 매개변수2 ...);</code></pre>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;">다음은 몬스터이름[name] 레벨[level] 공격력[atk] 를 멤버변수로 가지는 Monster 클래스의 생성자를 정의한 예제이다.&nbsp;</span></p>
<pre id="code_1707609822938" class="java" data-ke-language="java" data-ke-type="codeblock"><code>public class Monster {
    String name;
    int level;
    int atk;

    // Constructor - 클래스명과 동일하게 작성
    Monster(String name, int level, int atk) {
        this.name = name;
        this.level = level;
        this.atk = atk;
    }
}</code></pre>
<pre id="code_1707610068179" class="java" data-ke-language="java" data-ke-type="codeblock"><code>public class MonsterMain {
    public static void main(String[] args) {
        Monster normalSlime = new Monster("normalSlime", 10, 1);
        System.out.println("name : " + normalSlime.name + ", level : " + normalSlime.level + ", atk : " + normalSlime.atk);
    }
}</code></pre>
<pre id="code_1707610169523" class="java" data-ke-language="java" data-ke-type="codeblock"><code>name : normalSlime, level : 10, atk : 1</code></pre>
<hr contenteditable="false" data-ke-type="horizontalRule" data-ke-style="style5" />
<h2 data-ke-size="size26"><span style="font-family: 'Nanum Gothic'; color: #000000; text-align: start;">#2 Constructor Overloading &amp; this() keyword</span></h2>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000; text-align: start;"><span style="background-color: #333333; color: #dddddd;">Constructor Overloading [생성자 오버로딩]</span> 이란, <b>서로 다른 매개변수를 받는 생성자를 여러개 작성하는 문법</b>이다. 반환값이 없다는 것을 제외하면 메서드 오버로딩 방식과 거의 동일하다.&nbsp;</span></p>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000; text-align: start;">예를 들어 위에서 작성한 슬라임 객체를 생성할 때 이름[name]과 레벨[level]만을 매개변수로 받고 공격력[atk]은 선택 사항으로 남겨두고 싶을 수 도 있다.</span></p>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000; text-align: start;">다음은 이름, 레벨, 공격력을 모두 매개변수로 받는 생성자와, 생성자 오버로딩 방식을 사용해 이름, 레벨 만을 매개변수로 받는 생성자를 작성한 예제 코드이다.</span></p>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000; text-align: start;">공격력을 매개변수로 보내지 않으면, 자동으로 0으로 초기화된다.</span></p>
<pre id="code_1707610472065" class="java" data-ke-language="java" data-ke-type="codeblock"><code>package constructor;

public class Monster {
    String name;
    int level;
    int atk;

    // Constructor - 클래스명과 동일하게 작성
    Monster(String name, int level, int atk) {
        this.name = name;
        this.level = level;
        this.atk = atk;
    }

    // Constructor Overloadingg
    Monster(String name, int level) {
        this.name = name;
        this.level = level;
        this.atk = 0;
    }
}</code></pre>
<pre id="code_1707610605120" class="java" data-ke-language="java" data-ke-type="codeblock"><code>public class MonsterMain {
    public static void main(String[] args) {
        Monster normalSlime = new Monster("normalSlime", 10, 1);
        Monster epicSlime = new Monster("epicSlime", 8);
        System.out.println("name : " + normalSlime.name + ", level : " + normalSlime.level + ", atk : " + normalSlime.atk);
        System.out.println("name : " + epicSlime.name + ", level : " + epicSlime.level + ", atk : " + epicSlime.atk);
    }
}</code></pre>
<pre id="code_1707610621420" class="java" data-ke-language="java" data-ke-type="codeblock"><code>name : normalSlime, level : 10, atk : 1
name : epicSlime, level : 8, atk : 0</code></pre>
<p data-ke-size="size16">&nbsp;</p>
<h4 data-ke-size="size20"><span style="font-family: 'Nanum Gothic'; color: #000000;">this() 키워드를 사용한 중복 제거&nbsp;</span></h4>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;">생성자 오버로딩 방식으로 작성한 생성자는 코드의 중복이 발생하는 경우가 있다. 이 때 <span style="background-color: #333333; color: #dddddd;">this()</span> 문법을 사용하면 중복되는 코드를 제거할 수 있다. this() 는 <b>생성자 내부에서 자신의 생성자를 호출하는 문법</b>이다.</span></p>
<pre id="code_1707610798189" class="java" data-ke-language="java" data-ke-type="codeblock"><code>package constructor;

public class Monster {
    String name;
    int level;
    int atk;

    // Constructor - 클래스명과 동일하게 작성
    Monster(String name, int level, int atk) {
        this.name = name;
        this.level = level;
        this.atk = atk;
    }

    // Constructor Overloadingg
    // this() 중복 제거
    Monster(String name, int level) {
        this(name, level, 0);
    }
}</code></pre>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;">단, 유의할점은 this() 문법은 <b>반드시 코드의 최상단 부분에 작성</b>해야 한다. 그렇지 않으면 컴파일 에러가 발생한다.</span></p>
<pre id="code_1707610989429" class="java" data-ke-language="java" data-ke-type="codeblock"><code>    // Constructor Overloadingg
    // this() 중복 제거
    Monster(String name, int level) {
    	...
        System.out.println("slime object") // error
        this(name, level, 0);
        ...
    }</code></pre>
<hr contenteditable="false" data-ke-type="horizontalRule" data-ke-style="style5" />
<h2 data-ke-size="size26"><span style="font-family: 'Nanum Gothic'; color: #000000;">#3 Default Constructor</span></h2>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;"><span style="background-color: #333333; color: #dddddd;">Default Constructor [기본 생성자]</span> 란, <b>매개변수가 없는 생성자로 클래스 내부에 생성자가 하나도 존재하지 않는 경우에 자바에서 자동으로 생성해 주는 생성자</b>이다. 굳이 이런 문법이 왜 필요한지 의문이 생길 수 있다. 그 이유는 자<b>바는 무조건 객체를 생성과 동시에 생성자를 반드시 하나는 호출해 주어야 한다</b>는 규칙이 있기에, 사용자 편의상 제공해 주는 기능이다.&nbsp;</span></p>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;">단, 생성자를 미리 정의한 경우에는 생성하지 않는다.</span></p>
<pre id="code_1707611287901" class="java" data-ke-language="java" data-ke-type="codeblock"><code>package constructor;

public class Monster {
    String name;
    int level;
    int atk;

    // default constructor
    Monster() {}
}</code></pre>
<p data-ke-size="size16">&nbsp;</p>
                        </div>
                        <br/>
                        <div class="tags">
                            
                        </div>
                    </div>
                </div>
            </div>
        </main>
    </div>
</div>
</body>
</html>
