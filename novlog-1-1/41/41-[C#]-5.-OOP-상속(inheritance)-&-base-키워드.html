
<meta charset="utf-8">
<html lang="ko">
<head>
    <link rel="stylesheet" type="text/css" href="./../style.css" />
    <title>[C#] 5. OOP 상속(inheritance) & base 키워드</title>
</head>
<body id="tt-body-page" class="">
<div id="wrap" class="wrap-right">
    <div id="container">
        <main class="main ">
            <div class="area-main">
                <div class="area-view">
                    <div class="article-header">
                        <div class="inner-article-header">
                            <div class="box-meta">
                                <h2 class="title-article">[C#] 5. OOP 상속(inheritance) & base 키워드</h2>
                                <div class="box-info">
                                    <p class="category">? Archive/C#</p>
                                    <p class="date">2021-05-31 19:37:10</p>
                                </div>
                            </div>
                        </div>
                    </div>
                    <hr>
                    <div class="article-view">
                        <div class="contents_style">
                            <p><figure class="imageblock alignLeft" data-origin-width="313" data-origin-height="319" data-filename="c#.png" width="200" height="204" data-ke-mobilestyle="widthOrigin">
    <span data-lightbox="lightbox">
        <img src="./img/img.png" data-origin-width="313" data-origin-height="319" data-filename="c#.png" width="200" height="204" data-ke-mobilestyle="widthOrigin" />
    </span>
    <figcaption></figcaption>
</figure></p>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #ffffff; background-color: #333333;">#5 OOP 상속(inheritance) &amp; base</span></p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16"><b><span style="font-family: 'Nanum Gothic'; color: #000000;">[목차]</span></b></p>
<ul style="list-style-type: disc;" data-ke-list-type="disc">
<li><span style="font-family: 'Nanum Gothic'; color: #000000;">1. 상속 이란?</span></li>
<li><span style="font-family: 'Nanum Gothic'; color: #000000;">2. base() 로 부모의 생성자 특정하기</span></li>
<li><span style="font-family: 'Nanum Gothic'; color: #000000;">3. base 로 부모의 요소 가져다 쓰기</span></li>
</ul>
<p data-ke-size="size16"><b><span style="color: #000000; font-family: 'Nanum Gothic';">* 개인적인 공부 기록용으로 작성한 글이기에 잘못된 내용이 있을 수 있습니다.</span></b></p>
<hr contenteditable="false" data-ke-type="horizontalRule" data-ke-style="style5" />
<h2 data-ke-size="size26"><b><span style="font-family: 'Nanum Gothic'; color: #000000;">#1 상속 이란?</span></b></h2>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;"><span style="background-color: #333333; color: #ffffff;">상속</span>은 <span style="background-color: #333333; color: #ffffff;">객체지향(OOP)의 3대 요소중 하나</span>로, 매우 중요한 개념입니다. 상속에 대하여 예시를 통해 알아 보도록 하겠습니다.</span></p>
<p data-ke-size="size16"><span style="color: #000000;">RPG 게임에서 아래와 같은 Knight(기사) 클래스가 존재한다고 가정해 봅시다.&nbsp;</span></p>
<pre id="code_1622455587305" class="cs" data-ke-language="cs" data-ke-type="codeblock"><code>    class Knight
    {
        public int hp;
        public int mp;
        public int atk;
        public int def;

        public void Attack()
        {
            Console.WriteLine("Attack!");
        }

        public void Move()
        {
            Console.WriteLine("Move!");
        }
    }</code></pre>
<p data-ke-size="size16"><span style="color: #000000; font-family: 'Nanum Gothic';">그런데 만약 Mage(마법사), Archor(궁수) 클래스를 업데이트 해야 한다면 각각 hp, mp, atk(공격력), def(방어력), Attack(), Move() 등을 아래 처럼 하나하나 다 재정의 해주어야 할 것입니다.</span></p>
<pre id="code_1622455751694" class="cs" data-ke-language="cs" data-ke-type="codeblock"><code>    class Mage
    {
        public int hp;
        public int mp;
        public int atk;
        public int def;

        public void Attack()
        {
            Console.WriteLine("Attack!");
        }

        public void Move()
        {
            Console.WriteLine("Move!");
        }
    }

    class Archor
    {
        public int hp;
        public int mp;
        public int atk;
        public int def;

        public void Attack()
        {
            Console.WriteLine("Attack!");
        }

        public void Move()
        {
            Console.WriteLine("Move!");
        }
    }</code></pre>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;">직업이 겨우 3개이기에 망정이지 넥슨에서 운영하는 메이플스토리(Maplestory) 게임은 직업의 개수만 40여개가 넘어갑니다. 더하여 몬스터 클래스를 제작할 경우에는 몇백가지의 속성들을 타이핑 해야만 합니다.</span></p>
<p data-ke-size="size16"><span style="color: #000000;">이러한 비효율적인 작업을 해결하기 위해 객체지향(OOP) 프로그래밍에서는 상속이라는 기능을 제공합니다.</span></p>
<p><figure class="imageblock alignLeft" data-origin-width="545" data-origin-height="193" width="424" height="150" data-ke-mobilestyle="widthOrigin">
    <span data-lightbox="lightbox">
        <img src="./img/img_1.png" data-origin-width="545" data-origin-height="193" width="424" height="150" data-ke-mobilestyle="widthOrigin" />
    </span>
    <figcaption></figcaption>
</figure></p>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;"><span style="background-color: #333333; color: #ffffff;">상속은 부모클래스와 자식 클래스로 나뉘며, 자식 클래스는 부모 클래스의 모든 기능(함수,변수 등등)을 상속 받아서 사용이 가능</span>합니다.</span></p>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;">저는 Player라는 부모 클래스에 모든 기능을 넣은 뒤 , 자식 클래스 (Knight , Mage , Archor) 들에게 부모의 기능을 상속 시켰습니다. <span style="background-color: #333333; color: #ffffff;">상속을 받는 방법</span>은 <span style="background-color: #333333; color: #ffffff;">자식 클래스 이름 오른쪽에 콜론(:)</span>과 함께 <span style="background-color: #333333; color: #ffffff;">부모 클래스의 이름</span>을 적어 주면 됩니다.</span></p>
<pre id="code_1622456154380" class="cs" data-ke-language="cs" data-ke-type="codeblock"><code>    class Player 
    {
        public int hp;
        public int mp;
        public int atk;
        public int def;

        public void Attack()
        {
            Console.WriteLine("Attack!");
        }

        public void Move()
        {
            Console.WriteLine("Move!");
        }
    }
    class Knight : Player
    {

    }

    class Mage : Player
    {

    }

    class Archor : Player
    {

    }</code></pre>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;">한 눈에 보기에도 코드가 매우 간결해 졌습니다. 그리고 만약 자식클래스 만의 필드를 정의하고 싶다면, 자식클래스 안에 기능들을 정의해 주면 됩니다. <span style="background-color: #ffc1c8;">(단, 부모 클래스는 자식 클래스의 기능을 상속받지 못합니다.)</span></span></p>
<hr contenteditable="false" data-ke-type="horizontalRule" data-ke-style="style6" />
<h2 data-ke-size="size26"><b><span style="font-family: 'Nanum Gothic'; color: #000000;">#2 base()로 부모의 생성자 특정하기</span></b></h2>
<p data-ke-size="size16"><span style="color: #000000;"><span style="background-color: #333333; color: #ffffff;">생성자의 호출 순서</span>는 <span style="background-color: #333333; color: #ffffff;">부모 -&gt; 자식</span> 순서입니다. 예시로 아래처럼 Knight(기사) 자식 클래스 객체를 생성해 보도록 하겠습니다.</span></p>
<pre id="code_1622456682907" class="cs" data-ke-language="cs" data-ke-type="codeblock"><code>namespace TextRpg
{

    class Player 
    {
        public int hp;
        public int mp;
        public int atk;
        public int def;

        public void Attack()
        {
            Console.WriteLine("Attack!");
        }

        public void Move()
        {
            Console.WriteLine("Move!");
        }

        public Player()
        {
            hp = 100;
            mp = 10;
            atk = 10;
            def = 10;
            Console.WriteLine("Player(부모) 생성자 호출");
        }
    }
    class Knight : Player
    {
       public Knight()
       {
            Console.WriteLine("Knight(자식) 생성자 호출");
       }
    }

    class Mage : Player
    {

    }

    class Archor : Player
    {

    }

    class Program
    {
        static void Main(string[] args)
        {
            Knight knight = new Knight();
        }
    }
}</code></pre>
<pre id="code_1622456700971" class="cs" data-ke-language="cs" data-ke-type="codeblock"><code>[실행결과]
Player(부모) 생성자 호출
Knight(자식) 생성자 호출</code></pre>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;">보시다 싶이, 부모(Player)의 생성자가 먼저 호출되고, 자식(Knight)의 생성자가 호출 되었습니다.</span></p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;">또한, 부모의 생성자가 여러 개라면 <span style="background-color: #333333; color: #ffffff;">base()</span> 키워드를 이용해서 <span style="background-color: #666666; color: #ffffff;">부모의 생성자를 특정</span>하는 것이 가능합니다.&nbsp;</span></p>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;"><span style="background-color: #333333; color: #ffffff;">사용 방법</span>은 <span style="background-color: #333333; color: #ffffff;">자식클래스 이름 오른쪽</span>에 <span style="background-color: #333333; color: #ffffff;">콜론(:) 과 함께 base()를 붙여 주면 됩니다.</span> <span style="color: #ffffff; background-color: #666666;">괄호 안에 아무것도 넣지 않으면 기본 생성자가 호출되고, 괄호 안에 파라미터를 넣어주면 그에 맞는 생성자가 호출됩니다.</span></span></p>
<pre id="code_1622456895921" class="cs" data-ke-language="cs" data-ke-type="codeblock"><code>namespace TextRpg
{

    class Player 
    {
        public int hp;
        public int mp;
        public int atk;
        public int def;

        public void Attack()
        {
            Console.WriteLine("Attack!");
        }

        public void Move()
        {
            Console.WriteLine("Move!");
        }

        public Player()
        {
            hp = 100;
            mp = 10;
            atk = 10;
            def = 10;
            Console.WriteLine("Player(부모) 생성자 호출");
        }

        public Player(int hp)
        {
            this.hp = hp;
            mp = 10;
            atk = 10;
            def = 10;
            Console.WriteLine("int형 Player(부모) 생성자 호출");
        }
    }
    class Knight : Player
    {
       public Knight() : base(50)
       {
            Console.WriteLine("Knight(자식) 생성자 호출");
       }
    }

    class Program
    {
        static void Main(string[] args)
        {
            Knight knight = new Knight();
        }
    }
}</code></pre>
<pre id="code_1622456910203" class="cs" data-ke-language="cs" data-ke-type="codeblock"><code>[출력결과]
int형 Player(부모) 생성자 호출
Knight(자식) 생성자 호출</code></pre>
<hr contenteditable="false" data-ke-type="horizontalRule" data-ke-style="style6" />
<h2 data-ke-size="size26"><b><span style="font-family: 'Nanum Gothic'; color: #000000;">#3 base 로 부모의 요소 가져다 쓰기</span></b></h2>
<p data-ke-size="size16"><span style="color: #000000;"><span style="background-color: #333333; color: #ffffff;">base</span> 키워드를 이용해 <span style="background-color: #666666; color: #ffffff;">부모의 필드를 가져다 쓰는 것 도 가능</span>합니다.&nbsp;</span><span style="color: #000000;">다음은 <span style="background-color: #333333; color: #ffffff;">자식(knight)의 생성자에서 부모(player) 필드의 요소를 가져다가 재 정의한 예제</span>입니다.</span><span style="color: #000000;"><span style="background-color: #333333; color: #ffffff;">사용 방법</span>은 <span style="background-color: #333333; color: #ffffff;">"base.부모필드 요소이름"</span>&nbsp;처럼 작성하면 됩니다.</span></p>
<pre id="code_1622457057449" class="cs" data-ke-language="cs" data-ke-type="codeblock"><code>    class Player 
    {
        public int hp;
        public int mp;
        public int atk;
        public int def;

        public void Attack()
        {
            Console.WriteLine("Attack!");
        }

        public void Move()
        {
            Console.WriteLine("Move!");
        }

        public Player()
        {
            hp = 100;
            mp = 10;
            atk = 10;
            def = 10;
            Console.WriteLine("Player(부모) 생성자 호출");
        }
    }
    class Knight : Player
    {
       public Knight() : base()
       {
            base.hp = 100;
            base.mp = 5;
            base.atk = 20;
            base.def = 30;
            Console.WriteLine("Knight(자식) 생성자 호출");
       }
    }</code></pre>
<hr contenteditable="false" data-ke-type="horizontalRule" data-ke-style="style6" />
                        </div>
                        <br/>
                        <div class="tags">
                            #Java #BASE #c# #OOP #접근 #부모클래스 #base() #자식클래스 #상속성 
                        </div>
                    </div>
                </div>
            </div>
        </main>
    </div>
</div>
</body>
</html>
