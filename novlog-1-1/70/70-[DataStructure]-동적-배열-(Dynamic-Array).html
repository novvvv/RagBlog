
<meta charset="utf-8">
<html lang="ko">
<head>
    <link rel="stylesheet" type="text/css" href="./../style.css" />
    <title>[DataStructure] 동적 배열 (Dynamic Array)</title>
</head>
<body id="tt-body-page" class="">
<div id="wrap" class="wrap-right">
    <div id="container">
        <main class="main ">
            <div class="area-main">
                <div class="area-view">
                    <div class="article-header">
                        <div class="inner-article-header">
                            <div class="box-meta">
                                <h2 class="title-article">[DataStructure] 동적 배열 (Dynamic Array)</h2>
                                <div class="box-info">
                                    <p class="category">? Archive/Algorithm</p>
                                    <p class="date">2021-07-03 20:22:20</p>
                                </div>
                            </div>
                        </div>
                    </div>
                    <hr>
                    <div class="article-view">
                        <div class="contents_style">
                            <p><figure class="imageblock alignCenter" data-origin-width="171" data-origin-height="153" data-ke-mobilestyle="widthOrigin">
    <span data-lightbox="lightbox">
        <img src="./img/img.png" data-origin-width="171" data-origin-height="153" data-ke-mobilestyle="widthOrigin" />
    </span>
    <figcaption></figcaption>
</figure></p>
<h2 style="text-align: center;" data-ke-size="size26"><span style="font-family: 'Noto Serif KR';">#동적 배열 (Dynamic Array)</span></h2>
<p style="text-align: center;" data-ke-size="size18"><b><span style="font-family: 'Nanum Gothic'; color: #000000;">#1 동적 배열이란?</span></b></p>
<p style="text-align: center;" data-ke-size="size18"><b><span style="font-family: 'Nanum Gothic'; color: #000000;">#2 resize()</span></b></p>
<p style="text-align: center;" data-ke-size="size18"><b><span style="font-family: 'Nanum Gothic'; color: #000000;">#3 append()</span></b></p>
<p style="text-align: center;" data-ke-size="size18"><b><span style="font-family: 'Nanum Gothic'; color: #000000;">#4 재할당</span></b></p>
<p style="text-align: center;" data-ke-size="size18">&nbsp;</p>
<p style="text-align: center;" data-ke-size="size16"><span style="background-color: #f6e199; font-family: 'Nanum Gothic';">* 개인적인 공부 내용을 기록한 글 이기에, 잘못된 내용이 있을 수 있습니다.</span></p>
<hr contenteditable="false" data-ke-type="horizontalRule" data-ke-style="style5" />
<h2 data-ke-size="size26"><span style="font-family: 'Noto Serif KR'; color: #000000;">#1 동적 배열이란?</span></h2>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;">동적 배열 (Dynamic Array) 는 가장 기본이 되는 선형 자료 구조인 배열 (Array) 을 이용해 만들어 낸 별도의 자료구조, 배열의 특성을 그대로 이어받는다.</span></p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size18"><span style="font-family: 'Noto Serif KR'; color: #000000; background-color: #f6e199;">* 배열의 특성이란?</span></p>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;">1. 배열의 모든 원소들은 메모리의 연속된 위치에 저장된다.</span></p>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;">2. 특정 위치의 원소의 값을 반환하거나, 변경하는 연산은 O(1)의 시간 복잡도를 가진다.</span><span style="font-family: 'Nanum Gothic'; color: #000000;"></span></p>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;">그러나, 동적 배열은 배열의 특성과 함께 다음 특성들도 추가로 가진다.</span></p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size18"><span style="font-family: 'Noto Serif KR'; color: #000000; background-color: #f6e199;">* 동적 배열 만의 특성</span></p>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;">1. resize() 연산을 통해 배열의 크기를 변경이 가능하며, N에 비례하는 시간이 걸린다.</span></p>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;">2. append() 연산을 통해 배열 맨 끝에 원소를 추가하는 것이 가능하며, 상수 시간이 걸린다.</span></p>
<hr contenteditable="false" data-ke-type="horizontalRule" data-ke-style="style5" />
<h2 data-ke-size="size26"><span style="font-family: 'Noto Serif KR'; color: #000000;">#2&nbsp; resize()</span></h2>
<h2 data-ke-size="size26">&nbsp;</h2>
<p><span style="color: #000000;"><span style="background-color: #dddddd;">resize() 연산을 구현하는 방법</span>은 간단하다. <span style="background-color: #dddddd;">단순히 새 배열을 동적으로 할당 받아서, 기존 배열의 원소들을 새로 할당받은 배열에 복사 시킨 뒤, 포인터가 새로운 배열을 참조하도록 변경하면 된다.</span> 이러한 방식을 사용하면, O(N)의 시간 복잡도로 resize() 연산을 구현하는 것이 가능하다.</span></p>
<pre id="code_1625309465368" class="c++ arduino" data-ke-language="c++" data-ke-type="codeblock"><code>int size; // 현재 배열의 크기
aryElementType* aryp; // 새로운 배열을 참조 할 포인터</code></pre>
<hr contenteditable="false" data-ke-type="horizontalRule" data-ke-style="style5" />
<h2 data-ke-size="size26"><span style="font-family: 'Noto Serif KR'; color: #000000;">#3 append()</span></h2>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;">append() 연산을 호출할 때 마다 resize() 연산을 호출해 버리면, 상수 시간이 아닌 O(N) 시간 복잡도를 가지고 말아 버린다.</span></p>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;">append() 연산을 구현하는 방법은 여유분 메모리를 미리 할당 받아 두는 것이다.</span></p>
<p><figure class="imageblock alignLeft" data-origin-width="461" data-origin-height="213" width="409" height="189" data-ke-mobilestyle="widthOrigin">
    <span data-lightbox="lightbox">
        <img src="./img/img_1.png" data-origin-width="461" data-origin-height="213" width="409" height="189" data-ke-mobilestyle="widthOrigin" />
    </span>
    <figcaption></figcaption>
</figure></p>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;"><span style="background-color: #dddddd;">실제 원소의 수</span>를 <span style="background-color: #333333; color: #ffffff;">size</span> , <span style="background-color: #dddddd;">여유 메모리를 포함한 할당받은 메모리의 크기를</span> 배열의 용량 <span style="background-color: #333333; color: #ffffff;">capacity</span> 로 표현한다. 이렇게 여유 메모리를 미리 배열에 할당시켜 두면 append() 연산을 수행할 때 size의 값을 1 늘리고 그 위치에 새로운 값을 할당 시키기만 하면 된다.</span></p>
<p><figure class="imageblock alignLeft" data-origin-width="489" data-origin-height="138" width="450" height="126" data-ke-mobilestyle="widthOrigin">
    <span data-lightbox="lightbox">
        <img src="./img/img_2.png" data-origin-width="489" data-origin-height="138" width="450" height="126" data-ke-mobilestyle="widthOrigin" />
    </span>
    <figcaption></figcaption>
</figure></p>
<pre id="code_1625310050838" class="c++ arduino" data-ke-language="c++" data-ke-type="codeblock"><code>ary[size++] = newValue;</code></pre>
<hr contenteditable="false" data-ke-type="horizontalRule" data-ke-style="style5" />
<h2 data-ke-size="size26"><span style="font-family: 'Noto Serif KR'; color: #000000;">#4 재할당</span></h2>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;">그런데 <span style="background-color: #dddddd;">만약 size의 값과 capacity의 값이 일치해서 더 이상 size의 값을 늘릴 수 없는 상황이 오면 어떻게 해결할 것인가?</span></span></p>
<p><figure class="imageblock alignLeft" data-origin-width="485" data-origin-height="137" width="451" height="127" data-ke-mobilestyle="widthOrigin">
    <span data-lightbox="lightbox">
        <img src="./img/img_3.png" data-origin-width="485" data-origin-height="137" width="451" height="127" data-ke-mobilestyle="widthOrigin" />
    </span>
    <figcaption></figcaption>
</figure></p>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;"><span style="background-color: #dddddd;">해결 방법은 더 큰 새로운 배열을 동적 할당을 받은 뒤, 기존 배열의 원소들을 모두 복사하고, 새로운 배열을 가리킬 포인터와 바꿔치기 하는 것이다.</span> 이러한 과정을 <span style="background-color: #333333; color: #ffffff;">재할당(reallocate)</span> 이라고 부른다.</span></p>
<pre id="code_1625310498341" class="c++ arduino" data-ke-language="c++" data-ke-type="codeblock"><code>// size와 capacity값이 동일한 경우
if (size == capacity) {
	// 정해진 값 M 만큼의 새로운 배열을 새로 할당한다.
    int newCapacity = capacity + M;
    int* newArray = new int[newCapacity];
    // 기존 배열의 원소들을 복사한다.
    for (int i = 0 ; i &lt; size ; ++i
    	newArray[i] = array[i];
    // 기존 배열을 삭제한 뒤 , 새로운 배열로 바꾼다.
    if (array) delete [] array;
    array = newArray;
    capacity = newCapacity;
    }
// size의 값을 1 늘리고, 새로운 값(newValue)를 추가한다.    
array[size++] = newValue;</code></pre>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;">하지만 위와 같은 방법으로 미리 정해둔 값(M)을 늘리는 방식으로 재할당을 구현하면, 문제가 발생한다. append() 연산을 여러번 하다 보면 필연적으로 재할당이 일어날 수 밖에 없고 그러하면, 상수 시간의 시간복잡도를 갖지 못하기 때문이다.</span></p>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;">단순히 M의 값을 크게 늘리면 되지 않을까? 라고 생각할 수 도 있겠지만, 만약 M의 값을 10000 으로 설정했다고 가정하면 10개의 원소를 가지는 배열을 정의 한다고 해도 10000개의 공간을 할당 받아야 하기 때문에 매우 비효율 적이다.</span></p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #ffffff; background-color: #333333;">상수 시간에 append() 연산을 구현하는 팁은 현재 가진 원소의 개수에 비례한 여유분 메모리를 확보하는 데 있다.</span></p>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;">만약 배열의 원소의 개수가 2개라면, 4개의 메모리 값을 배열의 원소의 개수가 4개라면, 8개의 메모리 값을 확보해 두면 된다. 이렇게 하면 M을 지정해 두는 방식보다 매우 효율적이며, 일련의 과정을 무한히 반복 했을 때 평균적으로 append() 연산에 드는 시간 복잡도가 O(1) 이 되게 된다.</span></p>
<hr contenteditable="false" data-ke-type="horizontalRule" data-ke-style="style5" />
<h2 data-ke-size="size26"><span style="font-family: 'Noto Serif KR'; color: #000000;"># 마치며..</span></h2>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;">사실 동적 배열 (Dynamic Array) 를 직접 구현하는 일은 거의 없다. 왜냐하면 대부분의 언어에서 동적 배열을 표준 라이브러리에서 제공하기 때문이다. (대표적으로 C++ STL의 Vector가 있다.) 하지만 동적 배열의 원리를 알고 사용하는 것과 , 알지 못하고 사용하는 것에는 큰 차이가 있다고 생각해서 이렇게 정리하게 되었다.</span></p>
                        </div>
                        <br/>
                        <div class="tags">
                            #자료구조 #동적배열 #선형자료구조 
                        </div>
                    </div>
                </div>
            </div>
        </main>
    </div>
</div>
</body>
</html>
