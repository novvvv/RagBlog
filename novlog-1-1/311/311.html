
<meta charset="utf-8">
<html lang="ko">
<head>
    <link rel="stylesheet" type="text/css" href="./../style.css" />
    <title>[JAVA] Array vs ArrayList vs LinkedList 내부 구조 및 성능 비교</title>
</head>
<body id="tt-body-page" class="">
<div id="wrap" class="wrap-right">
    <div id="container">
        <main class="main ">
            <div class="area-main">
                <div class="area-view">
                    <div class="article-header">
                        <div class="inner-article-header">
                            <div class="box-meta">
                                <h2 class="title-article">[JAVA] Array vs ArrayList vs LinkedList 내부 구조 및 성능 비교</h2>
                                <div class="box-info">
                                    <p class="category">Back-end/Java Fundamental</p>
                                    <p class="date">2024-07-09 20:15:08</p>
                                </div>
                            </div>
                        </div>
                    </div>
                    <hr>
                    <div class="article-view">
                        <div class="contents_style">
                            <p style="text-align: center;" data-ke-size="size18">&nbsp;</p>
<p style="text-align: center;" data-ke-size="size18"><b><span style="font-family: 'Nanum Gothic'; color: #000000;">✨수정사항</span></b></p>
<p style="text-align: center;" data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;">- List Interface 제공 기능 파트 추가 2024.08.08</span></p>
<hr contenteditable="false" data-ke-type="horizontalRule" data-ke-style="style5" />
<h2 data-ke-size="size26"><b><span style="font-family: 'Nanum Gothic';">#1 Array&nbsp;</span></b></h2>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic';">배열은 자료구조를 처음 공부할때 배우는 가장 기본적인 자료구조이다. <a href="https://novlog.tistory.com/entry/Java-%EB%B0%B0%EC%97%B4-%EC%84%A0%EC%96%B8-%EB%B0%8F-%EB%A6%AC%ED%8C%A9%ED%86%A0%EB%A7%81-%EB%B0%A9%EB%B2%95-%EC%A0%95%EB%A6%AC" target="_blank" rel="noopener">About Array</a></span></p>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic';">배열은 내부 원소가 연속된 메모리 공간에 저장되어 있다.&nbsp;</span></p>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic';">따라서 <span style="background-color: #f6e199;"><b>원소가 저장된 위치만 알고 있다면 즉시 원소에 접근할 수 있다</b></span>는 장점을 가진 강력한 자료구조다.&nbsp;</span></p>
<p><figure class="imageblock alignLeft" width="333" height="187" >
    <span data-lightbox="lightbox">
        <img src="./img/img.png" width="333" height="187"  />
    </span>
    <figcaption></figcaption>
</figure></p>
<pre id="code_1720421032451" class="java" data-ke-language="java" data-ke-type="codeblock"><code>        String[] arr = {"n", "o", "v"};
        System.out.println(arr[2]);</code></pre>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;">하지만 일반 배열은 크기가 고정되어 있다는 한계를 가진다.&nbsp;</span></p>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;">이처럼 크기가 고정되어 있는 배열의 특징을 <span style="background-color: #333333; color: #dddddd;">정적 할당 (static allocation)</span> 이라고 한다.&nbsp;</span></p>
<hr contenteditable="false" data-ke-type="horizontalRule" data-ke-style="style5" />
<h2 data-ke-size="size26"><b><span style="font-family: 'Nanum Gothic'; color: #000000;">#2 List&nbsp;</span></b></h2>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;">크기가 고정되어 있다는 배열의 한계를 극복하기 위해 List 라는 자료구조가 탄생 하였다.&nbsp;</span></p>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;">리스트의 특징은 다음과 같다.&nbsp;</span></p>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #dddddd; background-color: #333333;">1. 데이터의 순서가 존재한다.&nbsp;</span></p>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #dddddd; background-color: #333333;">2. 데이터의 중복을 허용한다.&nbsp;</span></p>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #dddddd; background-color: #333333;">3. 리스트의 크기는 필요에 따라 동적으로 변한다.</span></p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;">Java는 <span style="background-color: #333333; color: #dddddd;">Collection framework</span>에서 다양한 형태의 최적화된 자료구조를 제공한다.</span></p>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;">그 중 리스트는 Collection framework에서 제공하는 가장 대표적인 자료구조로, 리스트의 내부 구조에 따라<span style="background-color: #c0d1e7;"> 2가지 형태 (ArrayList, LinkedList) 의 리스트를 제공</span>한다.</span></p>
<p><figure class="imageblock alignLeft" >
    <span data-lightbox="lightbox">
        <img src="./img/img_1.png"  />
    </span>
    <figcaption></figcaption>
</figure></p>
<p data-ke-size="size16">&nbsp;</p>
<h3 data-ke-size="size23"><b><span style="font-family: 'Nanum Gothic'; color: #000000;">#2.1 ArrayList</span></b></h3>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;"><span style="background-color: #333333; color: #dddddd;">ArrayList</span>는 <span style="background-color: #c0d1e7;">배열을 사용하여 데이터를 관리하는 리스트</span>이다.&nbsp;</span></p>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;">리스트 내부에 원소가 가득차면 대략 리스트의 크기를 50% 정도 늘려가는 방식으로 동작한다.&nbsp;</span></p>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;">따라서 구현 방식은 배열과 동일하기에 크기가 동적으로 늘어난다는 점을 제외하곤 동일한 방식으로 동작된다.</span></p>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;">그렇기에 배열과 마찬가지로 <span style="background-color: #c0d1e7;">특정 원소가 저장된 위치를 알고 있다면 1번의 연산 만으로 데이터에 접근 가능</span>하다는 강력한 이점을 가진다.</span></p>
<p><figure class="imageblock alignLeft" width="824" height="251" >
    <span data-lightbox="lightbox">
        <img src="./img/img_2.png" width="824" height="251"  />
    </span>
    <figcaption></figcaption>
</figure></p>
<pre id="code_1720422781988" class="java" data-ke-language="java" data-ke-type="codeblock"><code>import java.util.ArrayList;
import java.util.List;

public class test {
    public static void main(String[] args) {
        List&lt;Integer&gt; arrayList = new ArrayList&lt;&gt;();
        for (int i = 0; i &lt; 8; i++) {
            arrayList.add(i + 1);
        }
        System.out.println("ArrayList 내부 원소 출력");
        for (Integer integer : arrayList) {
            System.out.print(integer + " ");
        }
    }
}</code></pre>
<pre id="code_1720422792317" class="java" data-ke-language="java" data-ke-type="codeblock"><code>ArrayList 내부 원소 출력
1 2 3 4 5 6 7 8</code></pre>
<p data-ke-size="size16">&nbsp;</p>
<h4 data-ke-size="size20"><b><span style="font-family: 'Nanum Gothic'; color: #000000;">#배열 리스트의 원소 삽입</span></b></h4>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;">배열 리스트는 <span style="background-color: #c0d1e7;">중간에 원소를 삽입하는 경우</span>, 삽입하고자 하는 인덱스로 부터 뒤에 위치한 모든 원소를 한 칸씩 뒤로 미루는 방식으로 연산을 수행하기에 <span style="background-color: #333333; color: #dddddd;">O(N)</span> 만큼의 시간 복잡도가 소요된다.&nbsp;</span></p>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;">내부에 저장된 원소가 많을수록 더욱 많은 원소를 이동시키는 연산이 발생하기에, 중간 위치에 원소를 삽입할 경우 비교적 비효율적으로 동작한다는 단점을 가지고 있다.</span></p>
<p><figure class="imageblock alignLeft" >
    <span data-lightbox="lightbox">
        <img src="./img/img_3.png"  />
    </span>
    <figcaption></figcaption>
</figure></p>
<pre id="code_1720423789459" class="java" data-ke-language="java" data-ke-type="codeblock"><code>import java.util.ArrayList;
import java.util.List;

public class test {
    public static void main(String[] args) {
        List&lt;Integer&gt; arrayList = new ArrayList&lt;&gt;();
        for (int i = 0; i &lt; 8; i++) {
            arrayList.add(i + 1);
        }

        // 배열리스트 중간에 원소 추가
        // O(N) 만틈의 시간 복잡도가 소요
        arrayList.add(4, 0);

        System.out.println("ArrayList 내부 원소 출력");
        for (Integer integer : arrayList) {
            System.out.print(integer + " ");
        }
    }
}</code></pre>
<pre id="code_1720423798677" class="java" data-ke-language="java" data-ke-type="codeblock"><code>ArrayList 내부 원소 출력
1 2 3 4 0 5 6 7 8</code></pre>
<p data-ke-size="size16">&nbsp;</p>
<h3 data-ke-size="size23"><b><span style="font-family: 'Nanum Gothic'; color: #000000;">#2.2 Linked List</span></b></h3>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;">연결 리스트는 <span style="background-color: #333333; color: #dddddd;">노드 (객체)</span> 들의 집합으로 구성된 리스트이다.&nbsp;</span></p>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;">각 노드는 <span style="background-color: #c0d1e7;">원소와 다음 노드를 참조하는 참조값으로 구성</span>되어있다.</span></p>
<pre id="code_1720521558451" class="java" data-ke-language="java" data-ke-type="codeblock"><code>public class Node {
    Object item;
    Node next;

    public Node(Object item) {
        this.item = item;
    }
}</code></pre>
<p data-ke-size="size16">&nbsp;</p>
<h4 data-ke-size="size20"><b><span style="font-family: 'Nanum Gothic'; color: #000000;">#연결 리스트의 원소 접근&nbsp;</span></b></h4>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;">연결 리스트의 구조에 따라 순차 연결 리스트, 원형 연결 리스트 등 다양한 종류의 리스트로 구분한다.</span></p>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;">자바는 그 중에서 각 노드가 앞 뒤 정보를 모두 가지고 있는 <span style="background-color: #333333; color: #dddddd;">이중 연결 리스트</span> 형태로 구성되어 있다.&nbsp;&nbsp;</span></p>
<p><figure class="imageblock alignLeft" width="688" height="116" >
    <span data-lightbox="lightbox">
        <img src="./img/img_4.png" width="688" height="116"  />
    </span>
    <figcaption></figcaption>
</figure></p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;">배열 리스트와 달리 연결 리스트는 메모리의 연속된 공간에 배치되는 것이 아닌, 노드들의 연결로 이루어져 있기에 <span style="background-color: #c0d1e7;">인덱싱을 통해 원소에 바로 접근하는 것은 불가능</span>하다.&nbsp;</span></p>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;">따라서 특정 원소에 접근하고 싶다면 시작 노드 혹은 마지막 노드부터 순차적으로 탐색을 진행해야 하기에 평균적으로 <span style="background-color: #333333; color: #dddddd;">O(N)</span> 만큼의 시간 복잡도가 소요된다. </span></p>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;">이러한 특징으로 인해 <span style="background-color: #c0d1e7;">원소 접근 측면에서는 배열 리스트 보다 상당히 비효율적인 자료구조</span>이다.&nbsp;</span></p>
<p data-ke-size="size16">&nbsp;</p>
<h4 data-ke-size="size20"><span style="font-family: 'Nanum Gothic'; color: #000000;"><b>#연결 리스트의 원소 추가</b>&nbsp;</span></h4>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;">연결 리스트는 <span style="background-color: #c0d1e7;">중간에 원소를 추가하는 경우</span>에는 해당 원소까지 접근하는 과정이 필요하기에 <span style="background-color: #333333; color: #dddddd;">O(N)</span> 만큼의 시간 복잡도가 소요된다.</span></p>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;">반면 자바에서 연결 리스트는 시작 노드와 마지막 노드의 정보를 모두 담고 있는 이중 연결 리스트 구조이기에, <span style="background-color: #c0d1e7;">맨 앞 혹은 맨 뒤에 원소를 추가하는 경우</span> <span style="background-color: #333333; color: #dddddd;">O(1)</span> 만에 원소를 추가할 수 있어 강력한 성능을 보인다.&nbsp;</span></p>
<p data-ke-size="size16">&nbsp;</p>
<p><figure class="imageblock alignLeft" width="803" height="112" >
    <span data-lightbox="lightbox">
        <img src="./img/img_5.png" width="803" height="112"  />
    </span>
    <figcaption></figcaption>
</figure></p>
<hr contenteditable="false" data-ke-type="horizontalRule" data-ke-style="style5" />
<h2 data-ke-size="size26"><span style="font-family: 'Nanum Gothic'; color: #000000;"><b>#3 Array List Vs Linked List 성능 비교</b>&nbsp;</span></h2>
<table style="border-collapse: collapse; width: 100%; height: 107px;" border="1" data-ke-align="alignLeft" data-ke-style="style12">
<tbody>
<tr style="height: 17px;">
<td style="width: 33.3333%; height: 17px;">&nbsp;</td>
<td style="width: 33.3333%; height: 17px; text-align: center;"><span style="font-family: 'Nanum Gothic';"><b>Array List</b></span></td>
<td style="width: 33.3333%; height: 17px; text-align: center;"><span style="font-family: 'Nanum Gothic';"><b>Linked List</b></span></td>
</tr>
<tr style="height: 18px;">
<td style="width: 33.3333%; text-align: center; height: 18px;"><span style="font-family: 'Nanum Gothic';"><b>원소 추가/삭제 (중간)</b></span></td>
<td style="width: 33.3333%; text-align: center; height: 18px;"><span style="font-family: 'Nanum Gothic';">O(N)</span></td>
<td style="width: 33.3333%; text-align: center; height: 18px;"><span style="font-family: 'Nanum Gothic';">O(N)</span></td>
</tr>
<tr style="height: 18px;">
<td style="width: 33.3333%; text-align: center; height: 18px;"><span style="font-family: 'Nanum Gothic';"><b>원소 추가/삭제 (처음)</b></span></td>
<td style="width: 33.3333%; text-align: center; height: 18px;"><span style="font-family: 'Nanum Gothic';">O(N)</span></td>
<td style="width: 33.3333%; text-align: center; height: 18px;"><b><span style="font-family: 'Nanum Gothic';">O(1)</span></b></td>
</tr>
<tr style="height: 18px;">
<td style="width: 33.3333%; text-align: center; height: 18px;"><span style="font-family: 'Nanum Gothic';"><b>원소 추가/삭제 (마지막)&nbsp;</b></span></td>
<td style="width: 33.3333%; text-align: center; height: 18px;"><b><span style="font-family: 'Nanum Gothic';">O(1)</span></b></td>
<td style="width: 33.3333%; text-align: center; height: 18px;"><b><span style="font-family: 'Nanum Gothic';">O(1)</span></b></td>
</tr>
<tr style="height: 18px;">
<td style="width: 33.3333%; text-align: center; height: 18px;"><span style="font-family: 'Nanum Gothic';"><b>원소 접근</b></span></td>
<td style="width: 33.3333%; text-align: center; height: 18px;"><b><span style="font-family: 'Nanum Gothic';">O(1)</span></b></td>
<td style="width: 33.3333%; text-align: center; height: 18px;"><span style="font-family: 'Nanum Gothic';">O(N)</span></td>
</tr>
<tr style="height: 18px;">
<td style="width: 33.3333%; text-align: center; height: 18px;"><span style="font-family: 'Nanum Gothic';"><b>원소 탐색</b></span></td>
<td style="width: 33.3333%; text-align: center; height: 18px;"><span style="font-family: 'Nanum Gothic';">O(N)</span></td>
<td style="width: 33.3333%; text-align: center; height: 18px;"><span style="font-family: 'Nanum Gothic';">O(N)</span></td>
</tr>
</tbody>
</table>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;">배열 리스트는 특정 인덱스의 원소에 접근하는 데 좋은 성능을 보이며, 연결 리스트는 처음과 마지막에 원소를 삽입하는 경우 좋은 성능을 보인다.</span></p>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;">따라서 <span style="background-color: #c0d1e7;">앞과 뒤에 빈번한 원소 삽입 및 삭제가 일어나는 경우</span>에는 <span style="background-color: #333333; color: #dddddd;">연결 리스트</span>를, <span style="background-color: #c0d1e7;">특정 인덱스의 원소에 자주 접근해야 하는&nbsp;상황</span>에서는 <span style="background-color: #333333; color: #dddddd;">배열 리스트</span>를 사용하는 것이 좋다.&nbsp;</span></p>
<hr contenteditable="false" data-ke-type="horizontalRule" data-ke-style="style5" />
<h2 data-ke-size="size26"><b><span style="font-family: 'Nanum Gothic'; color: #000000;">#4 List Interface 제공 기능</span></b></h2>
<h3 data-ke-size="size23"><b><span style="font-family: 'Nanum Gothic'; color: #000000;">#4.1 List.of() static method</span></b></h3>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;"><span style="background-color: #333333; color: #dddddd;">List.of() 정적 메서드</span>에 배열을 넣어주면 <span style="background-color: #c0d1e7;">배열을 기반으로 불변 리스트를 생성</span>할 수 있다.&nbsp;</span></p>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;">예시로 특정 파라미터로 Collections 타입이 요구되는 경우에 배열을 리스트로 바꾸어 인자로 던져줄 때 사용하고는 한다. </span><span style="font-family: 'Nanum Gothic'; color: #000000;"></span></p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;">다음은 inputArr 배열의 각 원소를 List.of 메서드를 사용해 정적 리스트로 변환한 뒤, HashSet의 파라미터로 활용한 예제이다. </span></p>
<div style="background-color: #1e1f22; color: #bcbec4;">
<pre class="java" data-ke-language="java"><code>Integer[] inputArr = {30, 20, 20, 10, 10};
Set&lt;Integer&gt; hashSet = new HashSet&lt;&gt;(List.of(inputArr));
System.out.println("hashSet = " + hashSet);</code></pre>
</div>
<pre id="code_1723065638732" class="java" data-ke-language="java" data-ke-type="codeblock"><code>hashSet = [20, 10, 30]</code></pre>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;">또한 배열을 넣어주는것이 아닌 List.of 메서드에 바로 인자를 대입하여 초기화 하는 것 또한 가능하다.&nbsp;</span></p>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;">단, 유의해야 할 점은 앞에서도 말했듯이 <span style="background-color: #c0d1e7;">List.of 메서드로 생성된 리스트는 불변이기에 리스트에 값을 추가하거나 삭제하는 연산을 시도할 시 에러가 발생</span>한다.</span></p>
<pre id="code_1723066158871" class="java" data-ke-language="java" data-ke-type="codeblock"><code>        List&lt;Integer&gt; immutableList = List.of(1, 2, 3, 4, 5);
        System.out.println("immutableList = " + immutableList);
        // immutableList.add(1);</code></pre>
<pre id="code_1723066199887" class="java" data-ke-language="java" data-ke-type="codeblock"><code>immutableList = [1, 2, 3, 4, 5]</code></pre>
                        </div>
                        <br/>
                        <div class="tags">
                            
                        </div>
                    </div>
                </div>
            </div>
        </main>
    </div>
</div>
</body>
</html>
