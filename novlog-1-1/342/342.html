
<meta charset="utf-8">
<html lang="ko">
<head>
    <link rel="stylesheet" type="text/css" href="./../style.css" />
    <title>AtCoder ABC389 C問題 snake game with C++ code</title>
</head>
<body id="tt-body-page" class="">
<div id="wrap" class="wrap-right">
    <div id="container">
        <main class="main ">
            <div class="area-main">
                <div class="area-view">
                    <div class="article-header">
                        <div class="inner-article-header">
                            <div class="box-meta">
                                <h2 class="title-article">AtCoder ABC389 C問題 snake game with C++ code</h2>
                                <div class="box-info">
                                    <p class="category">Problem Solving/AtCoder</p>
                                    <p class="date">2025-02-08 20:36:44</p>
                                </div>
                            </div>
                        </div>
                    </div>
                    <hr>
                    <div class="article-view">
                        <div class="contents_style">
                            <h2 data-ke-size="size26"><span style="font-family: 'Nanum Gothic'; color: #000000;">#Info</span></h2>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic';"><a href="https://atcoder.jp/contests/abc389/tasks/abc389_c" target="_blank" rel="noopener&nbsp;noreferrer">https://atcoder.jp/contests/abc389/tasks/abc389_c</a></span></p>
<figure id="og_1739013703168" contenteditable="false" data-ke-type="opengraph" data-ke-align="alignCenter" data-og-type="website" data-og-title="C - Snake Queue" data-og-description="AtCoder is a programming contest site for anyone from beginners to experts. We hold weekly programming contests online." data-og-host="atcoder.jp" data-og-source-url="https://atcoder.jp/contests/abc389/tasks/abc389_c" data-og-url="https://atcoder.jp/contests/abc389/tasks/abc389_c" data-og-image="https://scrap.kakaocdn.net/dn/cWmJEt/hyYciVA0CA/kXdAhUDaPu51zppLeg3Rtk/img.png?width=280&amp;height=280&amp;face=0_0_280_280"><a href="https://atcoder.jp/contests/abc389/tasks/abc389_c" target="_blank" rel="noopener" data-source-url="https://atcoder.jp/contests/abc389/tasks/abc389_c">
<div class="og-image" style="background-image: url('https://scrap.kakaocdn.net/dn/cWmJEt/hyYciVA0CA/kXdAhUDaPu51zppLeg3Rtk/img.png?width=280&amp;height=280&amp;face=0_0_280_280');">&nbsp;</div>
<div class="og-text">
<p class="og-title" data-ke-size="size16">C - Snake Queue</p>
<p class="og-desc" data-ke-size="size16">AtCoder is a programming contest site for anyone from beginners to experts. We hold weekly programming contests online.</p>
<p class="og-host" data-ke-size="size16">atcoder.jp</p>
</div>
</a></figure>
<hr contenteditable="false" data-ke-type="horizontalRule" data-ke-style="style5" />
<h2 data-ke-size="size26"><span style="font-family: 'Nanum Gothic'; color: #000000;">#Solve</span></h2>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;">단순히 vector 혹은, 배열을 이용해 풀이하면 가장 최상단에 있는 뱀을 제거하는 코드에서 시간 복잡도가 O(N)만큼 소요됩니다.</span></p>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;">그렇기에 효율적으로 최상단의 원소를 제거하기 위해 <span style="background-color: #333333; color: #dddddd;">deque 자료구조를 사용</span>했습니다.&nbsp;</span></p>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;">또한 특정 위치의 뱀의 머리 좌표를 출력하는 과정에서 <span style="background-color: #333333; color: #dddddd;">단순히 for loop를 돌려버리면 마찬가지로 시간복잡도가 O(N)</span>만큼 걸립니다.&nbsp;</span></p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;">따라서 단순히 처음부터 모든 뱀의 길이를 더하는 것이 아닌, 뱀의 마지막 머리 좌표를 가리키는 변수&nbsp; last_head_ptr를 별도로 선언하여 deque에 원소를 삽입할 때 같이 추가하는 <span style="background-color: #333333; color: #dddddd;">prefix sum (누적합) 알고리즘</span>을 택하였습니다.&nbsp;</span></p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;">첫 번째 케이스를 예시로 들어보겠습니다.&nbsp;</span></p>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;">마지막 뱀의 머리 좌표 (last_head_ptr) 를 덱에 동시에 추가하여, 특정 머리 좌표를 출력하는 명령 (3, 2) 이 들어와도 <span style="color: #1a5490;">단순히 해당 좌표에 저장된 누적합을 출력하기만 하면 O(1)만에 문제를 해결 가능</span>합니다.&nbsp;</span></p>
<p><figure class="imageblock alignCenter" >
    <span data-lightbox="lightbox">
        <img src="./img/img.png"  />
    </span>
    <figcaption></figcaption>
</figure><figure class="imageblock alignLeft" width="611" height="449" >
    <span data-lightbox="lightbox">
        <img src="./img/img_1.png" width="611" height="449"  />
    </span>
    <figcaption></figcaption>
</figure></p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;">만약 가장 앞에 있는 뱀의 머리를 제거하는 명령(2) 이 들어와도 제거한 <span style="background-color: #333333; color: #dddddd;">머리의 길이를 저장하는 변수 (offset) 에 따로 정의한 뒤, 출력 명령이 들어왔을떄 보정값을 뺀 값을 출력하면 마찬가지로 O(1) 만에 문제를 해결</span> 가능합니다.</span></p>
<p><figure class="imageblock alignLeft" >
    <span data-lightbox="lightbox">
        <img src="./img/img_2.png"  />
    </span>
    <figcaption></figcaption>
</figure><figure class="imageblock alignLeft" width="519" height="507" >
    <span data-lightbox="lightbox">
        <img src="./img/img_3.png" width="519" height="507"  />
    </span>
    <figcaption></figcaption>
</figure></p>
<hr contenteditable="false" data-ke-type="horizontalRule" data-ke-style="style5" />
<h2 data-ke-size="size26"><span style="font-family: 'Nanum Gothic'; color: #000000;">#Code</span></h2>
<pre id="code_1739014520048" class="cpp" data-ke-language="cpp" data-ke-type="codeblock"><code>#include &lt;iostream&gt;
#include &lt;deque&gt;
#include &lt;utility&gt;
using namespace std;

int main(int argc, const char * argv[]) {
    
    ios_base::sync_with_stdio(false);
    cin.tie(0);
    int n;
    cin &gt;&gt; n;
    
    deque&lt;pair&lt;long long, long long&gt;&gt; snake_queue;
    long long offset = 0; // 좌표 보정값
    long long last_head_ptr = 0; // 마지막 뱀의 머리 위치
    
    for (int i = 0; i &lt; n; i++) {
        int command;
        cin &gt;&gt; command;
        // command 1 : l의 길이를 가지는 뱀을 뒤에 추가
        if (command == 1) {
            long long l;
            cin &gt;&gt; l;
            snake_queue.push_back({l, last_head_ptr});
            last_head_ptr += l;
        }
        // command 2 : 최상단에 있는 뱀을 제거
        else if (command == 2) {
            
            long long m = snake_queue.front().first;
            snake_queue.pop_front();
            offset += m; // 보정값, 제거할 뱀의 길이
        }
        // command 3 : 앞에서부터 k번째에 있는 뱀의 머리 좌표를 출력
        else {
            int k;
            cin &gt;&gt; k;
            cout &lt;&lt; snake_queue[k-1].second - offset &lt;&lt; '\n';
        }
        
    }
    
    return 0;
}</code></pre>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;">github&nbsp;</span></p>
<p data-ke-size="size16"><a href="https://github.com/novvvv/PS/blob/main/atCoder/ABC389_%E5%95%8F%E9%A1%8CC_Snake%20Queue.cpp" target="_blank" rel="noopener&nbsp;noreferrer">https://github.com/novvvv/PS/blob/main/atCoder/ABC389_%E5%95%8F%E9%A1%8CC_Snake%20Queue.cpp</a></p>
                        </div>
                        <br/>
                        <div class="tags">
                            
                        </div>
                    </div>
                </div>
            </div>
        </main>
    </div>
</div>
</body>
</html>
