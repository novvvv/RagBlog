
<meta charset="utf-8">
<html lang="ko">
<head>
    <link rel="stylesheet" type="text/css" href="./../style.css" />
    <title>[C++] Tokenizing : 문자열 파싱 _ split (with find & substr)</title>
</head>
<body id="tt-body-page" class="">
<div id="wrap" class="wrap-right">
    <div id="container">
        <main class="main ">
            <div class="area-main">
                <div class="area-view">
                    <div class="article-header">
                        <div class="inner-article-header">
                            <div class="box-meta">
                                <h2 class="title-article">[C++] Tokenizing : 문자열 파싱 _ split (with find & substr)</h2>
                                <div class="box-info">
                                    <p class="category">? Archive/C&C++</p>
                                    <p class="date">2022-05-28 19:54:45</p>
                                </div>
                            </div>
                        </div>
                    </div>
                    <hr>
                    <div class="article-view">
                        <div class="contents_style">
                            <p><figure class="imageblock alignCenter" >
    <span data-lightbox="lightbox">
        <img src="./img/img.png"  />
    </span>
    <figcaption></figcaption>
</figure></p>
<p style="text-align: center;" data-ke-size="size16"><b><span style="font-family: 'Nanum Gothic'; color: #ffffff; background-color: #333333;">[C++] Tokenizing</span></b></p>
<p style="text-align: center;" data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;">*개인적인 공부 내용을 기록하는 용도로 작성한 글 이기에 <u><b>잘못된 내용을 포함하고 있을 수 있습니다.</b></u></span></p>
<p style="text-align: center;" data-ke-size="size16"><span style="color: #1a5490;"><b><span style="font-family: 'Nanum Gothic';">_contents</span></b></span></p>
<p style="text-align: center;" data-ke-size="size16"><b><span style="font-family: 'Nanum Gothic'; color: #000000;">#1 Tokenizing</span></b></p>
<p style="text-align: center;" data-ke-size="size16"><b><span style="font-family: 'Nanum Gothic'; color: #000000;">#2 find &amp; substr function</span></b></p>
<p style="text-align: center;" data-ke-size="size16"><b><span style="font-family: 'Nanum Gothic'; color: #000000;">#3 split</span></b></p>
<p style="text-align: center;" data-ke-size="size16"><b><span style="font-family: 'Nanum Gothic'; color: #000000;">*공백을 기준으로 2개의 token 생성</span></b></p>
<p style="text-align: center;" data-ke-size="size16"><b><span style="font-family: 'Nanum Gothic'; color: #000000;">*공백을 기준으로 3개 이상의 token 생성</span></b></p>
<hr contenteditable="false" data-ke-type="horizontalRule" data-ke-style="style5" />
<h2 style="text-align: left;" data-ke-size="size26"><b><span style="font-family: 'Nanum Gothic'; color: #000000;">#1 Tokenizing</span></b></h2>
<p style="text-align: left;" data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;"><span style="background-color: #333333; color: #dddddd;">Tokenizing</span>이란 <span style="color: #1a5490;"><b>Text를 delimiter(공백, 특수문자 등)을 기준으로 여러개의 Token으로 나누는 것</b></span>을 의미한다.</span></p>
<p style="text-align: left;" data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;">그리고 이런 Tokenizing을 수행하는 것을 Tokenizer 이라고 하는데 대표적으로 <span style="color: #dddddd; background-color: #333333;"><b>split 함수</b></span>가 있다.</span></p>
<p style="text-align: left;" data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;">하지만 JAVA, Python과 같은 언어들과는 달리 C++은 별도의 Tokenizer를 제공하지 않는다. 하지만 <span style="background-color: #333333; color: #dddddd;">find, substr</span> 함수를 사용하여 Tokenizing을 구현할 수 있다.</span></p>
<hr contenteditable="false" data-ke-type="horizontalRule" data-ke-style="style6" />
<h2 style="text-align: left;" data-ke-size="size26"><b><span style="font-family: 'Nanum Gothic'; color: #000000;">#2 find &amp; substr function</span></b></h2>
<p style="text-align: left;" data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;"><span style="color: #000000;">Tokenizing을 구현하기 이전에 <span style="background-color: #333333; color: #dddddd;">find / substr 함수</span>에 대해 간략하게 알아 보도록 하자.</span></span></p>
<pre id="code_1653732181528" class="cpp" data-ke-language="cpp" data-ke-type="codeblock"><code>문자열이름.find("탐색할 문자열");
// 탐색 성공 : 찾고자 하는 문자의 첫 번째 인덱스 주소 반환
// 탐색 실패 : string::npos 리턴 (무작위 long long 가비지 값)</code></pre>
<p style="text-align: left;" data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;"><span style="background-color: #333333; color: #dddddd;">string.find</span> 함수는 <b>특정 문자열에서 원하는 문자열을 찾는 기능을 수행하는 함수</b>로, <b>문자열 탐색에 성공</b>했을 경우 <span style="color: #781b33;"><b>문자의 첫 번째 인덱스 주소</b></span>를 반환하고, <b>문자열 탐색에 성공하지 못했을 경우</b>에는 <span style="color: #781b33;"><b>string::npos를 리턴</b></span>한다. <a href="https://novlog.tistory.com/136?category=860653" target="_blank" rel="noopener">_link</a></span></p>
<pre id="code_1653732229867" class="cpp" data-ke-language="cpp" data-ke-type="codeblock"><code>문자열이름.substr(시작위치, 길이);
// 문자열의 시작 위치로 부터 길이 만큼의 문자열을 잘라낸다.</code></pre>
<p style="text-align: left;" data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;"><span style="background-color: #333333; color: #dddddd;">substr</span> 함수는 <b>지정된 길이의 문자열을 잘라내는 기능을 수행하는 함수</b>이다.<b>첫 번째 인자로 시작 위치</b>를 <b>두 번째 인자로 길이</b>를 넣어 주어 시작 위치부터 길이에 해당하는 문자열을 취득한다.</span></p>
<hr contenteditable="false" data-ke-type="horizontalRule" data-ke-style="style6" />
<h2 style="text-align: left;" data-ke-size="size26"><b><span style="font-family: 'Nanum Gothic'; color: #000000;">#3 split</span></b></h2>
<p style="text-align: left;" data-ke-size="size18"><span style="color: #1a5490;"><b><span style="font-family: 'Nanum Gothic';">* 3.1 공백을 기준으로 2개의 token 생성</span></b></span></p>
<p style="text-align: left;" data-ke-size="size16"><span style="color: #000000; font-family: 'Nanum Gothic';">앞서 공부한 find, substr 함수를 이용해 "Let's learn!" 문자열(Text)를 공백(delimiter)을 기준으로 2개의 Token(Let's , Learn!)으로 나누어 보도록 하겠다.</span></p>
<p style="text-align: left;" data-ke-size="size16">&nbsp;</p>
<p style="text-align: left;" data-ke-size="size16"><span style="color: #000000; font-family: 'Nanum Gothic';">우선 <span style="background-color: #333333; color: #dddddd;">find 함수</span>를 이용해 공백의 인덱스를 delimiter에 저장한다.</span></p>
<pre id="code_1653732797088" class="cpp" data-ke-language="cpp" data-ke-type="codeblock"><code>	string str = "Let's Learn";
	int delimiter = str.find(' '); // 5</code></pre>
<p style="text-align: left;" data-ke-size="size16">&nbsp;</p>
<p style="text-align: left;" data-ke-size="size16"><span style="color: #000000; font-family: 'Nanum Gothic';">다음으로 <span style="background-color: #333333; color: #dddddd;">substr 함수</span>를 이용해 from 문자열에 공백 앞의 문자열을 저장하고, to 문자열에는 delimiter + 1 즉, 공백 이후의 문자열을 저장한 뒤 출력한다.&nbsp;</span></p>
<pre id="code_1653732861248" class="cpp" data-ke-language="cpp" data-ke-type="codeblock"><code>	string from = str.substr(0, delimiter); // "Let's"
	string to = str.substr(delimiter + 1); // "Learn"
	cout &lt;&lt; "from : " &lt;&lt; from &lt;&lt; endl &lt;&lt;
		"to : " &lt;&lt; to &lt;&lt; endl;</code></pre>
<pre id="code_1653732934540" class="cpp" data-ke-language="cpp" data-ke-type="codeblock"><code>[출력결과] 
from : Let's
to : Learn</code></pre>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size18"><span style="color: #1a5490;"><b><span style="font-family: 'Nanum Gothic';">* 3.2 공백을 기준으로 3개 이상의 token 생성</span></b></span></p>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;">이번에는 "Let's Learn Tokenizing!"문자열을 3개의 토큰으로 나누어 보도록 하겠다. 2개의 token으로 나누는 것 보다 약간 복잡하다.</span></p>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;">우선 잘라낸 token을 저장할 <span style="background-color: #333333; color: #dddddd;">tok vector</span>를 선언한 뒤, <span style="background-color: #333333; color: #dddddd;">insert 함수</span>를 이용해 <b>문자열 마지막에 공백을 추가</b>해 준다. (공백을 추가해 주지 않으면 마지막 문자열이 들어가지 않는다.)</span></p>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;">다음으로 pos가 <span style="background-color: #333333; color: #dddddd;">string::npos</span>를 가리킬 때 <b>(string.find 함수는 탐색에 실패하면 string::npos를 리턴한다.)</b> 즉, 더 이상 delimiter(공백)을 찾지 못할 때 까지 while 반복문을 돌린다.</span></p>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;">그리고 첫 공백이 나올 때 까지 문자열을 잘라내어 tok vector에 push한 뒤, 잘라낸 문자열은 <span style="background-color: #333333; color: #dddddd;">string.erase 함수</span>를 사용해 삭제한다.</span></p>
<pre id="code_1653734674067" class="cpp" data-ke-language="cpp" data-ke-type="codeblock"><code>#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;vector&gt;
using namespace std;

int main(){
	string str = "Let's Learn Tokenizing!";
	str.insert(str.length(), " "); // 문자열 마지막에 공백 추가
	string delimiter = " ";
	vector&lt;string&gt; tok{}; // str을 tokenizing한 token을 저장할 vector	
	size_t pos = 0;	
	// pos가 string::npos를 가리킬 때, 즉, 문자열의 끝에 도달할 때 까지 탐색
	while((pos = str.find(delimiter)) != string::npos){
		// 0 ~ 공백이 나올 때 까지 문자열을 잘라내어 tok vector에 push
		tok.push_back(str.substr(0, pos));
		// 잘라낸 문자열은 erase 함수를 이용해 삭제
		str.erase(0, pos + delimiter.length());
	}
	
	for(const auto &amp;s : tok)
		cout &lt;&lt; s &lt;&lt; endl;
	
	return 0;
}</code></pre>
<pre id="code_1653735250539" class="cpp" data-ke-language="cpp" data-ke-type="codeblock"><code>[실행결과]
Let's
Learn
Tokenizing!</code></pre>
                        </div>
                        <br/>
                        <div class="tags">
                            #C++ #STL #split #문자열자르기 #Tokenizing #문자열공백기준자르기 
                        </div>
                    </div>
                </div>
            </div>
        </main>
    </div>
</div>
</body>
</html>
