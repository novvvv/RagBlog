
<meta charset="utf-8">
<html lang="ko">
<head>
    <link rel="stylesheet" type="text/css" href="./../style.css" />
    <title>[BOJ] C++ 2468 "안전 영역" 문제 풀이 _ nov</title>
</head>
<body id="tt-body-page" class="">
<div id="wrap" class="wrap-right">
    <div id="container">
        <main class="main ">
            <div class="area-main">
                <div class="area-view">
                    <div class="article-header">
                        <div class="inner-article-header">
                            <div class="box-meta">
                                <h2 class="title-article">[BOJ] C++ 2468 "안전 영역" 문제 풀이 _ nov</h2>
                                <div class="box-info">
                                    <p class="category">? Archive/ProblemSolving</p>
                                    <p class="date">2022-03-26 17:01:15</p>
                                </div>
                            </div>
                        </div>
                    </div>
                    <hr>
                    <div class="article-view">
                        <div class="contents_style">
                            <h2 data-ke-size="size26"><span style="color: #781b33;"><b><span style="font-family: 'Nanum Gothic';">#<span style="color: #000000;">INFO</span></span></b></span></h2>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;">난이도 : <span style="background-color: #dddddd;">SILVER1</span></span></p>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;">문제유형 : <span style="background-color: #333333; color: #ffffff;">BFS</span></span></p>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic';"><span style="color: #000000;">출처 :</span> <a href="https://www.acmicpc.net/problem/2468">2468번: 안전 영역 (acmicpc.net)</a></span></p>
<figure id="og_1648220076778" contenteditable="false" data-ke-type="opengraph" data-ke-align="alignCenter" data-og-type="website" data-og-title="2468번: 안전 영역" data-og-description="재난방재청에서는 많은 비가 내리는 장마철에 대비해서 다음과 같은 일을 계획하고 있다. 먼저 어떤 지역의 높이 정보를 파악한다. 그 다음에 그 지역에 많은 비가 내렸을 때 물에 잠기지 않는 " data-og-host="www.acmicpc.net" data-og-source-url="https://www.acmicpc.net/problem/2468" data-og-url="https://www.acmicpc.net/problem/2468" data-og-image="https://scrap.kakaocdn.net/dn/bYW5ZJ/hyNOwJNm1A/7l1IfnKMV8DNHO2zfGDtz0/img.png?width=2834&amp;height=1480&amp;face=0_0_2834_1480"><a href="https://www.acmicpc.net/problem/2468" target="_blank" rel="noopener" data-source-url="https://www.acmicpc.net/problem/2468">
<div class="og-image" style="background-image: url('https://scrap.kakaocdn.net/dn/bYW5ZJ/hyNOwJNm1A/7l1IfnKMV8DNHO2zfGDtz0/img.png?width=2834&amp;height=1480&amp;face=0_0_2834_1480');">&nbsp;</div>
<div class="og-text">
<p class="og-title" data-ke-size="size16">2468번: 안전 영역</p>
<p class="og-desc" data-ke-size="size16">재난방재청에서는 많은 비가 내리는 장마철에 대비해서 다음과 같은 일을 계획하고 있다. 먼저 어떤 지역의 높이 정보를 파악한다. 그 다음에 그 지역에 많은 비가 내렸을 때 물에 잠기지 않는</p>
<p class="og-host" data-ke-size="size16">www.acmicpc.net</p>
</div>
</a></figure>
<p><figure class="imageblock alignLeft" >
    <span data-lightbox="lightbox">
        <img src="./img/img.png"  />
    </span>
    <figcaption></figcaption>
</figure><figure class="imageblock alignCenter" >
    <span data-lightbox="lightbox">
        <img src="./img/img_1.png"  />
    </span>
    <figcaption></figcaption>
</figure><figure class="imageblock alignCenter" >
    <span data-lightbox="lightbox">
        <img src="./img/img_2.png"  />
    </span>
    <figcaption></figcaption>
</figure></p>
<hr contenteditable="false" data-ke-type="horizontalRule" data-ke-style="style5" />
<h2 data-ke-size="size26"><b><span style="font-family: 'Nanum Gothic'; color: #000000;"><span style="color: #781b33;">#</span>SOLVE</span></b></h2>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;">특정한 높이에서 물에 잠기지 않은 영역의 최대 개수를 구하는 문제이다. 예를들어 높이가 3 이하인 모든 지점이 물에 잠겼다고 가정하면 아래 그림과 같이 4가지 구역으로 나뉘어 진다.&nbsp;</span></p>
<p><figure class="imageblock alignLeft" >
    <span data-lightbox="lightbox">
        <img src="./img/img_3.png"  />
    </span>
    <figcaption></figcaption>
</figure></p>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;">높이가 0부터 보드 내에서 가장 큰 높이인 9까지 모든 경우의 수를 탐색해 가장 나뉘어지는 구역이 많은 케이스를 선택하는 브루트포스 방식으로 문제를 풀이했다.</span></p>
<pre id="code_1648220812675" class="c++ arduino" data-ke-language="c++" data-ke-type="codeblock"><code>#define X first
#define Y second
int board[103][103]; // 물의 높이를 저장할 배열
int rain[103][103]; // 1 : 물에 잠긴 지역 , 0 : 물에 잠기지 않은 지역
int isVisited[103][103]; // 방문 여부를 저장할 배열
int dx[4] = {-1, 0, 1, 0};
int dy[4] = {0, -1, 0, 1};</code></pre>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;"><span style="background-color: #dddddd;">int board[103][103]</span> : 물의 높이 정보를 저장할 배열이다.</span></p>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;"><span style="background-color: #dddddd;">int rain[103][103]</span> : 각 지역이 물에 잠겼는지 여부를 저장할 배열이다. (1 : 물에 잠긴 지역, 0 : 물에 잠기지 않은 지역)</span></p>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;"><span style="background-color: #dddddd;">int isVisited[103][103]</span> : BFS 알고리즘에서 방문 여부를 저장할 배열이다.</span></p>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;"><span style="background-color: #dddddd;">int dx[4], dy[4]</span> : BFS 알고리즘에서 상하좌우 탐색을 도와줄 변수이다.</span></p>
<p data-ke-size="size16">&nbsp;</p>
<pre id="code_1648220940112" class="c++ arduino" data-ke-language="c++" data-ke-type="codeblock"><code>	int n;
	cin &gt;&gt; n;
	int maxLimit = -1;
	for(int i = 0; i &lt; n; i++){
		for(int j = 0; j &lt; n; j++){
			cin &gt;&gt; board[i][j];
			maxLimit = max(board[i][j], maxLimit);
		}
	}</code></pre>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;">중첩 for문을 통해 높이 정보를 입력받고, 배열 내의 가장 큰 높이를 maxLimit 변수에 저장한다.</span></p>
<p data-ke-size="size16">&nbsp;</p>
<pre id="code_1648221064507" class="c++ arduino" data-ke-language="c++" data-ke-type="codeblock"><code>int count[maxLimit]; // 모든 높이의 구역의 개수를 저장할 배열
	for(int limit = 0; limit &lt;= maxLimit; limit++) {
		// Init Array
		for(int i = 0; i &lt; n; i++) {
			fill(rain[i], rain[i] + n, 0);
			fill(isVisited[i], isVisited[i] + n, 0);
		}
		
		// Check Area
		for(int i = 0; i &lt; n; i++){
			for(int j = 0; j &lt; n; j++){
				if(board[i][j] &lt;= limit) rain[i][j] = 1;
			}
		}
 }</code></pre>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;"><span style="background-color: #dddddd;">int count[maxLimit]</span> : 모든 높이 (0 ~ 9(maxLimit))의 구역의 개수를 저장할 배열이다.</span></p>
<p data-ke-size="size16"><b><span style="font-family: 'Nanum Gothic'; color: #000000;">// Init Array Part</span></b></p>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;">fill 함수를 이용해 물에 잠긴 지역 여부를 판별하는 rain 배열과 BFS 알고리즘에서 방문 여부를 판별하는 isVisited 배열을 모두 0으로 초기화한다.</span></p>
<p data-ke-size="size16"><b><span style="font-family: 'Nanum Gothic'; color: #000000;">// Check Area Part</span></b></p>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;">for문을 돌면서 limit(현재 높이)보다 작은 지역은 모두 잠긴 지역 (rain[i][j] = 1) 으로 지정한다.</span></p>
<p data-ke-size="size16">&nbsp;</p>
<pre id="code_1648221434308" class="c++ arduino" data-ke-language="c++" data-ke-type="codeblock"><code>		//BFS
		int cnt = 0;
		for(int i = 0; i &lt; n; i++) {
			for(int j = 0; j &lt; n; j++) {
				queue&lt;pair&lt;int,int&gt;&gt; Q;
				// 물에 잠긴 지역이거나, 이미 방문한 지역인 경우 cotinue
				if(rain[i][j] == 1 || isVisited[i][j] == 1) continue;
				Q.push({i, j});
				isVisited[i][j] = 1;
				while(!Q.empty()){
					auto cur = Q.front();
					Q.pop();
					for(int dir = 0; dir &lt; 4; dir++){
						int nx = cur.X + dx[dir];
						int ny = cur.Y + dy[dir];
						if(nx &lt; 0 || nx &gt;= n || ny &lt; 0 || ny &gt;= n) continue;
						if(rain[nx][ny] == 1 || isVisited[nx][ny] == 1) continue;
						isVisited[nx][ny] = 1;
						Q.push({nx, ny});
					}
				}
				cnt++;
			}</code></pre>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;">전형적인 BFS 풀이이다.</span></p>
<p data-ke-size="size16">&nbsp;</p>
<pre id="code_1648221461961" class="c++ arduino" data-ke-language="c++" data-ke-type="codeblock"><code>	cout &lt;&lt; *max_element(count, count + sizeof(count)/sizeof(int)) &lt;&lt; '\n';</code></pre>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;">마지막으로 max_element 함수를 이용해 count 배열에 저장된 가장 큰 값을 출력한다.</span></p>
<hr contenteditable="false" data-ke-type="horizontalRule" data-ke-style="style5" />
<h2 data-ke-size="size26"><b><span style="font-family: 'Nanum Gothic';"><span style="color: #781b33;">#</span>CODE</span></b></h2>
<pre id="code_1648281624837" class="c++ arduino" data-ke-language="c++" data-ke-type="codeblock"><code>#include &lt;bits/stdc++.h&gt;
using namespace std;
#define X first
#define Y second
int board[103][103]; // 물의 높이를 저장할 배열
int rain[103][103]; // 1 : 물에 잠긴 지역 , 0 : 물에 잠기지 않은 지역
int isVisited[103][103]; // 방문 여부를 저장할 배열
int dx[4] = {-1, 0, 1, 0};
int dy[4] = {0, -1, 0, 1};

int main(int argc, char* argv[]) {
	ios::sync_with_stdio(0);
	cin.tie(0);
	int n;
	cin &gt;&gt; n;
	int maxLimit = -1;
	for(int i = 0; i &lt; n; i++){
		for(int j = 0; j &lt; n; j++){
			cin &gt;&gt; board[i][j];
			maxLimit = max(board[i][j], maxLimit);
		}
	}
	
	int count[maxLimit]; // 모든 높이의 구역의 개수를 저장할 배열
	for(int limit = 0; limit &lt;= maxLimit; limit++) {
		// Init Array
		for(int i = 0; i &lt; n; i++) {
			fill(rain[i], rain[i] + n, 0);
			fill(isVisited[i], isVisited[i] + n, 0);
		}
		
		// Check Area
		for(int i = 0; i &lt; n; i++){
			for(int j = 0; j &lt; n; j++){
				if(board[i][j] &lt;= limit) rain[i][j] = 1;
			}
		}

		//BFS
		int cnt = 0;
		for(int i = 0; i &lt; n; i++) {
			for(int j = 0; j &lt; n; j++) {
				queue&lt;pair&lt;int,int&gt;&gt; Q;
				// 물에 잠긴 지역이거나, 이미 방문한 지역인 경우 cotinue
				if(rain[i][j] == 1 || isVisited[i][j] == 1) continue;
				Q.push({i, j});
				isVisited[i][j] = 1;
				while(!Q.empty()){
					auto cur = Q.front();
					Q.pop();
					for(int dir = 0; dir &lt; 4; dir++){
						int nx = cur.X + dx[dir];
						int ny = cur.Y + dy[dir];
						if(nx &lt; 0 || nx &gt;= n || ny &lt; 0 || ny &gt;= n) continue;
						if(rain[nx][ny] == 1 || isVisited[nx][ny] == 1) continue;
						isVisited[nx][ny] = 1;
						Q.push({nx, ny});
					}
				}
				cnt++;
			}
		}
		count[limit] = cnt;
	}

	cout &lt;&lt; *max_element(count, count + sizeof(count)/sizeof(int)) &lt;&lt; '\n';
}</code></pre>
                        </div>
                        <br/>
                        <div class="tags">
                            #C++ #알고리즘 #소스코드 #문제풀이 #BOJ #백준 #2468 #안전영역 
                        </div>
                    </div>
                </div>
            </div>
        </main>
    </div>
</div>
</body>
</html>
