
<meta charset="utf-8">
<html lang="ko">
<head>
    <link rel="stylesheet" type="text/css" href="./../style.css" />
    <title>[BOJ] C++ 6593 "상범 빌딩" 문제 풀이 _ nov</title>
</head>
<body id="tt-body-page" class="">
<div id="wrap" class="wrap-right">
    <div id="container">
        <main class="main ">
            <div class="area-main">
                <div class="area-view">
                    <div class="article-header">
                        <div class="inner-article-header">
                            <div class="box-meta">
                                <h2 class="title-article">[BOJ] C++ 6593 "상범 빌딩" 문제 풀이 _ nov</h2>
                                <div class="box-info">
                                    <p class="category">? Archive/ProblemSolving</p>
                                    <p class="date">2022-03-28 10:22:36</p>
                                </div>
                            </div>
                        </div>
                    </div>
                    <hr>
                    <div class="article-view">
                        <div class="contents_style">
                            <h2 data-ke-size="size26"><b><span style="font-family: 'Nanum Gothic'; color: #000000;">#INFO</span></b></h2>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;">난이도 : <span style="background-color: #f6e199;">GOLD5</span></span></p>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;">문제유형 : <span style="background-color: #333333; color: #ffffff;">BFS</span></span></p>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic';"><span style="color: #000000;">출처 : </span><a href="https://www.acmicpc.net/problem/6593" target="_blank" rel="noopener">https://www.acmicpc.net/problem/6593</a></span></p>
<figure id="og_1648429684538" contenteditable="false" data-ke-type="opengraph" data-ke-align="alignCenter" data-og-type="website" data-og-title="6593번: 상범 빌딩" data-og-description="당신은 상범 빌딩에 갇히고 말았다. 여기서 탈출하는 가장 빠른 길은 무엇일까? 상범 빌딩은 각 변의 길이가 1인 정육면체(단위 정육면체)로 이루어져있다. 각 정육면체는 금으로 이루어져 있어 " data-og-host="www.acmicpc.net" data-og-source-url="https://www.acmicpc.net/problem/6593" data-og-url="https://www.acmicpc.net/problem/6593" data-og-image="https://scrap.kakaocdn.net/dn/buUbhx/hyNPFHfeZ5/K02SN9fEzIkk2dr2cZ9VWK/img.png?width=2834&amp;height=1480&amp;face=0_0_2834_1480"><a href="https://www.acmicpc.net/problem/6593" target="_blank" rel="noopener" data-source-url="https://www.acmicpc.net/problem/6593">
<div class="og-image" style="background-image: url('https://scrap.kakaocdn.net/dn/buUbhx/hyNPFHfeZ5/K02SN9fEzIkk2dr2cZ9VWK/img.png?width=2834&amp;height=1480&amp;face=0_0_2834_1480');">&nbsp;</div>
<div class="og-text">
<p class="og-title" data-ke-size="size16">6593번: 상범 빌딩</p>
<p class="og-desc" data-ke-size="size16">당신은 상범 빌딩에 갇히고 말았다. 여기서 탈출하는 가장 빠른 길은 무엇일까? 상범 빌딩은 각 변의 길이가 1인 정육면체(단위 정육면체)로 이루어져있다. 각 정육면체는 금으로 이루어져 있어</p>
<p class="og-host" data-ke-size="size16">www.acmicpc.net</p>
</div>
</a></figure>
<p><figure class="imageblock alignLeft" >
    <span data-lightbox="lightbox">
        <img src="./img/img.png"  />
    </span>
    <figcaption></figcaption>
</figure><figure class="imageblock alignLeft" >
    <span data-lightbox="lightbox">
        <img src="./img/img_1.png"  />
    </span>
    <figcaption></figcaption>
</figure></p>
<hr contenteditable="false" data-ke-type="horizontalRule" data-ke-style="style5" />
<h2 data-ke-size="size26"><b><span style="font-family: 'Nanum Gothic'; color: #000000;">#SOLVE</span></b></h2>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic';"><span style="color: #000000;">최근에 풀었던</span> <a href="https://novlog.tistory.com/191" target="_blank" rel="noopener">BOJ7569토마토</a> <span style="color: #000000;">문제와 거의 같은 문제였다. 다른 점 이라면 여러번 입력을 받는다는 정도..? 하지만 상범빌딩 문제를 풀며 부족했던 부분이 많이 보여 다시 정리해 보고자 한다.</span></span></p>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;">우선 6가지 방향으로 이동하기에 이동 변수를 잘 설정해 준다.</span></p>
<pre id="code_1648429817586" class="c++ arduino" data-ke-language="c++" data-ke-type="codeblock"><code>int dx[6] = {0, 0, 1, -1, 0, 0};
int dy[6] = {1, -1, 0, 0, 0, 0};
int dz[6] = {0, 0, 0, 0, 1, -1};</code></pre>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;">다음으로 BFS풀이에 필요한 기본 변수들을 선언해 준다.</span></p>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;"><span style="background-color: #dddddd;">char building</span> : 상범 빌딩의 정보를 저장할 배열이다.</span></p>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;"><span style="background-color: #dddddd;">int isBlocked</span> : 각 빌딩의 칸이 막혀있는지 여부를 저장할 배열이다. ( 0 : 뚫림 1 : 막힘 )</span></p>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;"><span style="background-color: #dddddd;">int distance</span> : 특정 칸 까지의 거리 정보를 저장할 배열이다.</span></p>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;"><span style="background-color: #dddddd;">bool isVisited</span> : BFS 알고리즘에서 방문 여부를 저장할 배열이다.</span></p>
<pre id="code_1648429927056" class="c++ arduino" data-ke-language="c++" data-ke-type="codeblock"><code>	int L, R, C;
	while(1){
		cin &gt;&gt; L &gt;&gt; R &gt;&gt; C;
		if(L == 0 &amp;&amp; R == 0 &amp;&amp; C == 0) break;
		queue&lt;pair&lt;int, pair&lt;int, int&gt;&gt;&gt; Q;				
		char building[MAX][MAX][MAX];
		int isBlocked[MAX][MAX][MAX];
		int distance[MAX][MAX][MAX];
		bool isVisited[MAX][MAX][MAX];</code></pre>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;">여러 케이스 루프를 돌 것 이기에 각 배열의 원소를 초기화 시켜준다. 처음에 테스트 케이스를 제출했을 때 이 부분을 빼먹어서 통과하지 못했다.</span></p>
<pre id="code_1648430109838" class="c++ arduino" data-ke-language="c++" data-ke-type="codeblock"><code>		for(int h = 0; h &lt; L; h++){
			for(int r = 0; r &lt; R; r++){
				for(int c = 0; c &lt; C; c++){
					isBlocked[h][r][c] = 0;
					distance[h][r][c] = 0;
					isVisited[h][r][c] = false;
				}
			}
		}</code></pre>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;"><span style="background-color: #dddddd;">isEscape</span> 변수는 <span style="color: #781b33;"><b>'E' 종점을 도달했는 지 여부를 판별할 변수</b></span>이다. 다음으로 3중 for문을 돌면서 'S' 시작점을 만나면 방문표시를 한 후 큐에 넣어주고, '#' 이동 불가칸을 만나면 <span style="background-color: #dddddd;">isBlocked[h][r][c]</span>를 <span style="color: #781b33;"><b>1로 초기화</b></span>시켜 <span style="color: #781b33;"><b>막혀있는 공간임을 표시</b></span>한다.</span></p>
<pre id="code_1648430153838" class="c++ arduino" data-ke-language="c++" data-ke-type="codeblock"><code>		bool isEscape = false;
		for(int h = 0; h &lt; L; h++){
			for(int r = 0; r &lt; R; r++){
				for(int c = 0; c &lt; C; c++){
					char temp;
					cin &gt;&gt; temp;
					building[h][r][c] = temp;
					// 'S' 스타트 구역. 방문표시를 한 뒤, 큐에 위치를 푸시한다.
					if(temp == 'S'){
						isVisited[h][r][c] = true;
						Q.push({h, {r, c}});
					}
					// '#' 막혀있는 공간이 나올 경우 빌딩의 원소를 1(지나갈 수 없음)로 설정
					else if(temp == '#'){
						isBlocked[h][r][c] = 1;
					}
				}
			}
		}</code></pre>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;">평범한 BFS 풀이이다. 'E' 출구를 만나면 "Escaped in () minute(s)." 문자를 출력하고, isEscape를 true로 만든 뒤 탈출한다. 만약 isEscape가 false인 상태로 반복문을 탈출했다면, 출구에 도달하지 못했다는 뜻 이기에 "Trapped!" 문자열을 출력한다.&nbsp;&nbsp;</span></p>
<pre id="code_1648430274734" class="c++ arduino" data-ke-language="c++" data-ke-type="codeblock"><code>		while(!Q.empty()){
			if(isEscape) break;
			auto cur = Q.front();
			Q.pop();
			for(int dir = 0; dir &lt; 6; dir++){
				int nx = cur.second.first + dx[dir];
				int ny = cur.second.second + dy[dir];
				int nz = cur.first + dz[dir];
				if(nx &lt; 0 || nx &gt;= R || ny &lt; 0 || ny &gt;= C || nz &lt; 0 || nz &gt;= L) continue;
				if(isVisited[nz][nx][ny] == true || isBlocked[nz][nx][ny] == 1) continue;
				distance[nz][nx][ny] = distance[cur.first][cur.second.first][cur.second.second] + 1;				
				if(building[nz][nx][ny] == 'E'){
					cout &lt;&lt; "Escaped in " &lt;&lt; distance[nz][nx][ny] &lt;&lt; " minute(s)." &lt;&lt; '\n';
					isEscape = true;
					break;
				} 				
				Q.push({nz, {nx, ny}});
				isVisited[nz][nx][ny] = 1;
			}

		}
        
        while(!Q.empty()) Q.pop();
		if(!isEscape) cout &lt;&lt; "Trapped!" &lt;&lt; '\n';</code></pre>
<hr contenteditable="false" data-ke-type="horizontalRule" data-ke-style="style5" />
<h2 data-ke-size="size26"><b><span style="font-family: 'Nanum Gothic'; color: #000000;">#CODE</span></b></h2>
<pre id="code_1648430490993" class="c++ arduino" data-ke-language="c++" data-ke-type="codeblock"><code>#include &lt;bits/stdc++.h&gt;
using namespace std;
const int MAX = 31;
int dx[6] = {0, 0, 1, -1, 0, 0};
int dy[6] = {1, -1, 0, 0, 0, 0};
int dz[6] = {0, 0, 0, 0, 1, -1};

int main(int argc, char* argv[]) {
	ios::sync_with_stdio(0);
	cin.tie(0);
	int L, R, C;
	while(1){
		cin &gt;&gt; L &gt;&gt; R &gt;&gt; C;
		if(L == 0 &amp;&amp; R == 0 &amp;&amp; C == 0) break;
		queue&lt;pair&lt;int, pair&lt;int, int&gt;&gt;&gt; Q;				
		char building[MAX][MAX][MAX];
		int isBlocked[MAX][MAX][MAX];
		int distance[MAX][MAX][MAX];
		bool isVisited[MAX][MAX][MAX];
		
		for(int h = 0; h &lt; L; h++){
			for(int r = 0; r &lt; R; r++){
				for(int c = 0; c &lt; C; c++){
					isBlocked[h][r][c] = 0;
					distance[h][r][c] = 0;
					isVisited[h][r][c] = false;
				}
			}
		}
		
		bool isEscape = false;
		for(int h = 0; h &lt; L; h++){
			for(int r = 0; r &lt; R; r++){
				for(int c = 0; c &lt; C; c++){
					char temp;
					cin &gt;&gt; temp;
					building[h][r][c] = temp;
					// 'S' 스타트 구역. 방문표시를 한 뒤, 큐에 위치를 푸시한다.
					if(temp == 'S'){
						isVisited[h][r][c] = true;
						Q.push({h, {r, c}});
					}
					// '#' 막혀있는 공간이 나올 경우 빌딩의 원소를 1(지나갈 수 없음)로 설정
					else if(temp == '#'){
						isBlocked[h][r][c] = 1;
					}
				}
			}
		}

		while(!Q.empty()){
			if(isEscape) break;
			auto cur = Q.front();
			Q.pop();
			for(int dir = 0; dir &lt; 6; dir++){
				int nx = cur.second.first + dx[dir];
				int ny = cur.second.second + dy[dir];
				int nz = cur.first + dz[dir];
				if(nx &lt; 0 || nx &gt;= R || ny &lt; 0 || ny &gt;= C || nz &lt; 0 || nz &gt;= L) continue;
				if(isVisited[nz][nx][ny] == true || isBlocked[nz][nx][ny] == 1) continue;
				distance[nz][nx][ny] = distance[cur.first][cur.second.first][cur.second.second] + 1;				
				if(building[nz][nx][ny] == 'E'){
					cout &lt;&lt; "Escaped in " &lt;&lt; distance[nz][nx][ny] &lt;&lt; " minute(s)." &lt;&lt; '\n';
					isEscape = true;
					break;
				} 				
				Q.push({nz, {nx, ny}});
				isVisited[nz][nx][ny] = 1;
			}

		}
		while(!Q.empty()) Q.pop();
		if(!isEscape) cout &lt;&lt; "Trapped!" &lt;&lt; '\n';
	}
	
	return 0;
}</code></pre>
                        </div>
                        <br/>
                        <div class="tags">
                            #C++ #알고리즘 #소스코드 #문제풀이 #BOJ #백준 #BFS #6593 #상범빌딩 
                        </div>
                    </div>
                </div>
            </div>
        </main>
    </div>
</div>
</body>
</html>
