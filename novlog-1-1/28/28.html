
<meta charset="utf-8">
<html lang="ko">
<head>
    <link rel="stylesheet" type="text/css" href="./../style.css" />
    <title>[알고리즘] 이진 탐색 알고리즘 (Binary Search Algorithm)</title>
</head>
<body id="tt-body-page" class="">
<div id="wrap" class="wrap-right">
    <div id="container">
        <main class="main ">
            <div class="area-main">
                <div class="area-view">
                    <div class="article-header">
                        <div class="inner-article-header">
                            <div class="box-meta">
                                <h2 class="title-article">[알고리즘] 이진 탐색 알고리즘 (Binary Search Algorithm)</h2>
                                <div class="box-info">
                                    <p class="category">? Archive/Algorithm</p>
                                    <p class="date">2021-05-14 13:15:38</p>
                                </div>
                            </div>
                        </div>
                    </div>
                    <hr>
                    <div class="article-view">
                        <div class="contents_style">
                            <hr contenteditable="false" data-ke-type="horizontalRule" data-ke-style="style5" />
<p><figure class="imageblock alignCenter" data-origin-width="1104" data-origin-height="140" data-ke-mobilestyle="widthOrigin">
    <span data-lightbox="lightbox">
        <img src="./img/img.png" data-origin-width="1104" data-origin-height="140" data-ke-mobilestyle="widthOrigin" />
    </span>
    <figcaption></figcaption>
</figure></p>
<p data-ke-size="size18"><b><span style="font-family: 'Nanum Gothic'; color: #000000;">#1 이진 탐색 알고리즘이란?</span></b></p>
<p data-ke-size="size18"><b><span style="font-family: 'Nanum Gothic'; color: #000000;">#2 구현 with C/C++</span></b><span style="font-family: 'Nanum Gothic'; color: #000000;"></span></p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #ffffff; background-color: #333333;">[도움되는 자료]</span></p>
<p data-ke-size="size16"><span style="color: #0593d3;"><a style="color: #0593d3;" href="https://novlog.tistory.com/25" target="_blank" rel="noopener"><span style="font-family: 'Nanum Gothic';">선형탐색 알고리즘 [Linear Search Algorithm]</span></a></span></p>
<p data-ke-size="size16"><span style="color: #0593d3;"><a style="color: #0593d3;" href="https://novlog.tistory.com/26" target="_blank" rel="noopener"><span style="font-family: 'Nanum Gothic';">BOJ 2776 암기왕</span></a></span></p>
<hr contenteditable="false" data-ke-type="horizontalRule" data-ke-style="style5" />
<h2 data-ke-size="size26"><span style="font-family: 'Nanum Gothic'; color: #000000;">#1 이진 탐색 알고리즘이란?</span></h2>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;"><b><span style="background-color: #333333; color: #ffffff;">이진 탐색 알고리즘 [Binary Search Algorithm]</span></b> 이란, 오름차순으로 정렬된 자료구조에서 특정한 값의 위치를 찾는 탐색 알고리즘 입니다. 처음부터 끝까지 하나하나 모두 검사하는 선형 탐색 알고리즘 <a href="https://novlog.tistory.com/25" target="_blank" rel="noopener">[Linear Search Algorithm]</a>과 달리 , 처음에 중간값을 선택한 후, 그 값보다 작은지 큰지를 비교하며 탐색을 수행합니다. <span style="background-color: #ffc1c8;">단, 정렬된 상태에서만 사용할 수 있다는 단점</span>을 가지고 있으나 선형 탐색 알고리즘에 비해서 키값을 찾는 연산이 반으로 줄어 <span style="background-color: #f6e199;">원소의 개수가 늘어날수록 효율이 증가 한다는 장점</span>을 가지고 있습니다.</span></p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;">정리하자면 이진 탐색 알고리즘은 절반은 나누면서 걸러내는 형식입니다. 원소의 탐색 과정을 순서로 나열해 보면 다음과 같습니다.</span><span style="font-family: 'Nanum Gothic'; color: #000000;"></span></p>
<ol style="list-style-type: decimal;" data-ke-list-type="decimal">
<li><span style="font-family: 'Nanum Gothic';">배열의 원소를 정렬한다.</span></li>
<li><span style="font-family: 'Nanum Gothic';">배열의 중간값을 탐색한다.</span></li>
<li><span style="font-family: 'Nanum Gothic';">중간값이 탐색값이면 탐색을 중단한다.</span></li>
<li><span style="font-family: 'Nanum Gothic';">중간값이 탐색값과 일치하지 않는다면 중간값과 탐색값을 비교한다.</span></li>
<li><span style="font-family: 'Nanum Gothic';">중간값 &gt; 탐색값 이라면, 중간값의 오른쪽 원소들은 제외한다.</span></li>
<li><span style="font-family: 'Nanum Gothic';">중간값 &lt; 탐색값 이라면, 중간값의 왼쪽 원소들은 제외한다.</span></li>
<li><span style="font-family: 'Nanum Gothic';">원소를 찾을 때 까지 5 ~ 6 과정을 반복한다.</span></li>
</ol>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;">오름차순으로 정렬된 배열 {1, 2, 3, 4, 5, 6, 7} 에서 7의 값을 찾는 과정을 그림을 통해 설명하도록 하겠습니다.</span></p>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;">우선, 가장 좌측의 값을 LEFT 변수에 가장 끝 값을 RIGHT에 초기화 한 뒤 MID에 (LEFT+RIGHT)/2의 값을 초기화 합니다.</span></p>
<p><figure class="imageblock alignLeft" data-origin-width="574" data-origin-height="243" width="442" height="187" data-ke-mobilestyle="widthOrigin">
    <span data-lightbox="lightbox">
        <img src="./img/img_1.png" data-origin-width="574" data-origin-height="243" width="442" height="187" data-ke-mobilestyle="widthOrigin" />
    </span>
    <figcaption></figcaption>
</figure></p>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;">다음으로 중간값(4)가 탐색값(7)과 일치하는지 여부를 확인합니다. 중간값(4) 이 탐색값(7)보다 작으므로, 탐색값은 중간값보다 오른쪽에 존재한다는 뜻입니다. LEFT값을 중간값 + 1인 [5]로 업데이트합니다. MID의 값은 자동으로 (LEFT(5)+RIGHT(7))/2 = 6 이 됩니다.</span></p>
<p><figure class="imageblock alignLeft" data-origin-width="574" data-origin-height="243" width="434" height="184" data-ke-mobilestyle="widthOrigin">
    <span data-lightbox="lightbox">
        <img src="./img/img_2.png" data-origin-width="574" data-origin-height="243" width="434" height="184" data-ke-mobilestyle="widthOrigin" />
    </span>
    <figcaption></figcaption>
</figure></p>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;">중간값(6)이 탐색값(7)과 일치하는지 여부를 확인합니다. 중간값(6)이 탐색값(7)보다 작으므로, 여전히 탐색값은 중간값보다 오른쪽에 존재한다는 뜻입니다. LEFT값을 중간값 + 1인 [7]로 초기화 합니다. MID의 값은 자동으로 (LEFT(7)+ RIGHT(7))/2 = 7이 됩니다.</span></p>
<p><figure class="imageblock alignLeft" data-origin-width="574" data-origin-height="243" width="435" height="184" data-ke-mobilestyle="widthOrigin">
    <span data-lightbox="lightbox">
        <img src="./img/img_3.png" data-origin-width="574" data-origin-height="243" width="435" height="184" data-ke-mobilestyle="widthOrigin" />
    </span>
    <figcaption></figcaption>
</figure></p>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;">마지막으로 중간값(7)과 탐색값(7)이 일치하는지 여부를 확인합니다. 일치하므로, 탐색을 종료하고 7값을 리턴합니다. (만약 탐색을 끝까지 수행했는데도, 탐색값이 존재하지 않는다면 -1을 리턴합니다.)</span></p>
<p><figure class="imageblock alignLeft" data-origin-width="582" data-origin-height="257" width="437" height="193" data-ke-mobilestyle="widthOrigin">
    <span data-lightbox="lightbox">
        <img src="./img/img_4.png" data-origin-width="582" data-origin-height="257" width="437" height="193" data-ke-mobilestyle="widthOrigin" />
    </span>
    <figcaption></figcaption>
</figure></p>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;">사실 대부분의 언어의 라브러리는 Binary Search Library 탐색 메소드를 제공합니다. (C++ 의 STL 표준 라이브러리, JAVA의 Array클래스 등등...) 그래서 굳이 특수한 경우가 아니라면, 구현하지 않고 제공해주는 메소드를 사용하면 됩니다.</span></p>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;">그러나, 직접 이진탐색을 구현하지도 못하는데 메소드만 사용하는것은 바람직하지 않으니 스스로 코드를 짤 수 있는 경우에만 사용하도록 합시다. :)&nbsp;</span></p>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;">다음은 <a href="https://novlog.tistory.com/26" target="_blank" rel="noopener">BOJ 2776 암기왕</a> 문제를 풀이한 것인데, 이진탐색 알고리즘을 연습하는데 도움이 될 것입니다.</span></p>
<p data-ke-size="size18">&nbsp;</p>
<h2 data-ke-size="size26"><span style="font-family: 'Nanum Gothic'; color: #000000;">#2 구현 with C/C++</span></h2>
<p data-ke-size="size16"><span style="color: #000000;">파라미터는 총 <span style="background-color: #333333; color: #ffffff;">①배열</span><span style="color: #ffffff;"> </span><span style="background-color: #333333; color: #ffffff;">②배열의 길이</span><span style="color: #ffffff;"> </span><span style="background-color: #333333; color: #ffffff;">③탐색값</span> 3가지입니다.</span></p>
<pre id="code_1620965344387" class="c++ arduino" data-ke-language="c++" data-ke-type="codeblock"><code>int binarySearch(int arr[], int len, int key)
{
	// 초기화
	int left = 0;
	int right = len - 1;
	int mid;
	
	while (left &lt;= right)
	{
		mid = (left + right) / 2;
		
		// 탐색에 성공한 경우 
		if (key == arr[mid])
		{
			return mid;
		}
		
		// 탐색값이 중간값보다 작은경우 (오른쪽 원소 배제) 
		else if (key &lt; arr[mid])
		{
			right = mid - 1;
		}
		
		// 탐색값이 중간값보다 큰 경우 (왼쪽 원소 배제) 
		else
		{
			left = mid + 1;
		}
	} 
	
	// 탐색에 실패한 경우 
	return -1;
}</code></pre>
                        </div>
                        <br/>
                        <div class="tags">
                            #C++ #C언어 #알고리즘 #이진탐색 #binarySearch #구현코드 
                        </div>
                    </div>
                </div>
            </div>
        </main>
    </div>
</div>
</body>
</html>
