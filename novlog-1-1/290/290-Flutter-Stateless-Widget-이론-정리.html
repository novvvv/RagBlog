
<meta charset="utf-8">
<html lang="ko">
<head>
    <link rel="stylesheet" type="text/css" href="./../style.css" />
    <title>Flutter Stateless Widget 이론 정리</title>
</head>
<body id="tt-body-page" class="">
<div id="wrap" class="wrap-right">
    <div id="container">
        <main class="main ">
            <div class="area-main">
                <div class="area-view">
                    <div class="article-header">
                        <div class="inner-article-header">
                            <div class="box-meta">
                                <h2 class="title-article">Flutter Stateless Widget 이론 정리</h2>
                                <div class="box-info">
                                    <p class="category">? Archive/Flutter</p>
                                    <p class="date">2023-03-11 00:12:32</p>
                                </div>
                            </div>
                        </div>
                    </div>
                    <hr>
                    <div class="article-view">
                        <div class="contents_style">
                            <p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;"><a href="https://novlog.tistory.com/entry/Flutter-%EA%B8%B0%EB%B3%B8-%EA%B5%AC%EC%A1%B0-%ED%8C%8C%EC%95%85%ED%95%98%EA%B8%B0-runApp-maindart" target="_blank" rel="noopener">이전 포스팅</a> 에서 얘기 했듯이 Flutter는 모든 것이 Widget으로 이루어져 있습니다.&nbsp;</span></p>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;">Widget을 생성하기 위해서는 Stateful Widget 그리고 Stateless Widget 중 하나를 extends(상속) 받아야 합니다.</span></p>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;">이번 포스팅에서는 Stateless Widget에 대해 공부한 내용을 정리해 보고자 합니다.&nbsp;</span></p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size18"><b><span style="font-family: 'Nanum Gothic'; color: #000000;">?INDEX</span></b></p>
<p data-ke-size="size18"><b><span style="font-family: 'Nanum Gothic'; color: #000000;">#1 Stateless Widget 생성하기</span></b></p>
<p data-ke-size="size16"><b><span style="font-family: 'Nanum Gothic'; color: #000000;">&nbsp; &nbsp; #1.1 Build Method</span></b></p>
<p data-ke-size="size16"><b><span style="font-family: 'Nanum Gothic'; color: #000000;">&nbsp; &nbsp; #1.2 Constructor</span></b></p>
<p data-ke-size="size16"><b><span style="font-family: 'Nanum Gothic'; color: #000000;">&nbsp; &nbsp; ?Stateless Widget 내부의 Property는 final로 선언하자</span></b></p>
<p data-ke-size="size18"><b><span style="font-family: 'Nanum Gothic'; color: #000000;">#2 Stateless Widget Life Cycle</span></b></p>
<p data-ke-size="size16"><b><span style="font-family: 'Nanum Gothic'; color: #000000;">&nbsp; &nbsp; ? Stateless Widget은 Immutable 하다.</span></b></p>
<p data-ke-size="size18"><b><span style="font-family: 'Nanum Gothic'; color: #000000;">#3 Stateless Widget Android Studio 단축키</span></b></p>
<hr contenteditable="false" data-ke-type="horizontalRule" data-ke-style="style5" />
<p data-ke-size="size18"><b><span style="font-family: 'Nanum Gothic'; color: #000000;"><span style="font-family: 'Nanum Gothic'; color: #000000;">?</span>Log</span></b></p>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;">2023.04.11 Stateless Widget Android Studio 단축키 내용 추가</span></p>
<hr contenteditable="false" data-ke-type="horizontalRule" data-ke-style="style5" />
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;"><b><span style="background-color: #dddddd;">Stateless Widget</span></b>은 이름에서 유추할 수 있듯이, <b>상태 변화가 없는 Widget</b>입니다. 즉, 한 번 UI가 그려지면 그 상태가 변하지 않습니다.&nbsp;</span></p>
<p data-ke-size="size16">&nbsp;</p>
<h2 data-ke-size="size26"><span style="color: #1a5490;"><b><span style="font-family: 'Nanum Gothic';">#1 Stateless Widget 생성하기</span></b></span></h2>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;"><b><span style="background-color: #dddddd;">StatelessWidget Class</span></b>를 상속 받으면 <b>Stateless Widget 을 생성</b>할 수 있습니다.&nbsp;</span></p>
<pre id="code_1678458114312" class="javascript" data-ke-language="javascript" data-ke-type="codeblock"><code>class MyApp extends StatelessWidget {
}</code></pre>
<p data-ke-size="size16">&nbsp;</p>
<h3 data-ke-size="size23"><span style="color: #000000;"><b><span style="font-family: 'Nanum Gothic';">#1.1 Build Method</span></b></span></h3>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;">StatelessWidget은 필수적으로 <b><span style="background-color: #dddddd;">Build Method</span></b>를 <b><span style="background-color: #dddddd;">override</span></b> 하여 구현해야 합니다.&nbsp;</span></p>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;">Build Method는 <b><span style="background-color: #dddddd;">BuildContext</span></b> 타입 <b><span style="background-color: #dddddd;">context Parameter</span></b>를 받아오며,<b> Build Method 를 통해 위젯의 구조 그리고, 속성을 정의</b>합니다.&nbsp;</span></p>
<pre id="code_1678458311539" class="javascript" data-ke-language="javascript" data-ke-type="codeblock"><code>class MyApp extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return ...
  }
}</code></pre>
<p data-ke-size="size16">&nbsp;</p>
<h3 data-ke-size="size23"><b><span style="font-family: 'Nanum Gothic'; color: #000000;">#1.2 Constructor&nbsp;</span></b></h3>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;">Constructor(생성자)는 필수는 아니지만, <b>StatelessWidget 외부에서 값을 받아와 속성을 정의할 때 사용합니다.&nbsp;</b></span></p>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;">Constructor를 정의하지 않으면 <b><span style="background-color: #dddddd;">Default Constuctor</span></b>가 자동으로 정의되며 구조는 다음과 같습니다.&nbsp;</span></p>
<pre id="code_1678459417683" class="javascript" data-ke-language="javascript" data-ke-type="codeblock"><code>const MyStatelessWidget({Key? key}) : super(key: key);</code></pre>
<p data-ke-size="size16">&nbsp;</p>
<h4 data-ke-size="size20"><b><span style="font-family: 'Nanum Gothic'; color: #000000;">? Stateless Widget 내부의 변수는 final로 선언하자</span></b></h4>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;"><b>Stateless Widget 내부에 변수를 선언</b>하는 경우 <span style="background-color: #333333; color: #dddddd;">final</span>로 선언한 뒤, 생성자에 <span style="background-color: #333333; color: #dddddd;">required keyword</span>를 사용해 <b>속성을 필수로 받아오게 하는 것</b>이 좋습니다. 이는 OOP의 특성 중 하나인 <b><span style="background-color: #dddddd;">불변성[Immutability]</span></b>을 보장하기 위함인데, <b>Stateless Widget은 어차피 한 번 생성되면 내부에 값이 변경되는 일이 없기에, final keyword로 변수를 모두 선언해 주면 프로그램의 안정성을 높이는 데 도움이 됩니다.&nbsp;</b></span></p>
<pre id="code_1678459806314" class="javascript" data-ke-language="javascript" data-ke-type="codeblock"><code>class MyApp extends StatelessWidget {
  // property
  final val1;
  
  // constructor
  const MyStatelessWidget({required this.val1, 
  Key? key,
  }) : super(key: key);
  
  // build method
  @override
  Widget build(BuildContext context) {
    return ...
  }
  
}</code></pre>
<hr contenteditable="false" data-ke-type="horizontalRule" data-ke-style="style5" />
<h2 data-ke-size="size26"><span style="color: #1a5490;"><b><span style="font-family: 'Nanum Gothic';">#2 Stateless Widget Life Cycle</span></b></span></h2>
<p><figure class="imageblock alignLeft" >
    <span data-lightbox="lightbox">
        <img src="./img/img.png"  />
    </span>
    <figcaption></figcaption>
</figure></p>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;">Stateless Widget의 내부 동작 Cycle은 매우 간단합니다. 먼저 <b>Constructor가 호출되며 다음으로 build Method가 호출</b>됩니다.&nbsp;</span></p>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;">단, <span style="background-color: #333333; color: #dddddd;">build Method</span>는 <b>Stateless Widget의 Life Cycle 도중 단 한 번 만 호출</b>됩니다.</span></p>
<p data-ke-size="size16">&nbsp;</p>
<h4 data-ke-size="size20"><b><span style="font-family: 'Nanum Gothic'; color: #000000;">? Stateless Widget은 Immutable 하다.</span></b></h4>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;">그렇기에 Stateless Widget은 <b><span style="background-color: #dddddd;">Immutable(불변)</span></b> 하다는 특성을 가지고 있습니다. 앞에서 여러번 언급 했듯이 <b>Stateless Widget에서 속성이 변경될 수 없으며, Stateless Widget 내부에서 Widget의 값을 변경하고자 한다면 기존의 Widget을 삭제하고 완전히 새로운 Widget을 생성 해야만 합니다.</b></span></p>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;">따라서 속성이 변경 가능한 유동적인 Widget을 만들고자 한다면 Stateful Widget으로 선언해 주어야 합니다.(Stateful Widget에 대해서는 뒤에서&nbsp; 다룰 예정입니다.)&nbsp;</span></p>
<hr contenteditable="false" data-ke-type="horizontalRule" data-ke-style="style5" />
<h2 data-ke-size="size26"><span style="color: #1a5490; font-family: 'Nanum Gothic';"><b>#3 Stateless Widget Android Studio 단축키</b></span></h2>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;">Android Studio에서 <span style="background-color: #333333; color: #dddddd;">stless</span>를 입력한 뒤 Enter를 누르면, <b>자동으로 Stateless Widget의 구조를 생성</b>해 줍니다. </span></p>
<p><figure class="imageblock alignLeft" >
    <span data-lightbox="lightbox">
        <img src="./img/img_1.png"  />
    </span>
    <figcaption></figcaption>
</figure></p>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;">다음과 같이 위젯의 이름을 제외한 코드가 생성되는데, 생성할 위젯의 이름만 명시해 주면 손쉽게 Stateless Widget 코드를 작성할 수 있습니다.</span></p>
<p><figure class="imageblock alignLeft" >
    <span data-lightbox="lightbox">
        <img src="./img/img_2.png"  />
    </span>
    <figcaption></figcaption>
</figure></p>
<pre id="code_1681182735583" class="javascript" data-ke-language="javascript" data-ke-type="codeblock"><code>class HomeScreen extends StatelessWidget {
  const HomeScreen({Key? key}) : super(key: key);

  @override
  Widget build(BuildContext context) {
    return const Placeholder();
  }
}</code></pre>
                        </div>
                        <br/>
                        <div class="tags">
                            
                        </div>
                    </div>
                </div>
            </div>
        </main>
    </div>
</div>
</body>
</html>
