
<meta charset="utf-8">
<html lang="ko">
<head>
    <link rel="stylesheet" type="text/css" href="./../style.css" />
    <title>[알고리즘] Dynamic Programming (동적 계획법, DP)</title>
</head>
<body id="tt-body-page" class="">
<div id="wrap" class="wrap-right">
    <div id="container">
        <main class="main ">
            <div class="area-main">
                <div class="area-view">
                    <div class="article-header">
                        <div class="inner-article-header">
                            <div class="box-meta">
                                <h2 class="title-article">[알고리즘] Dynamic Programming (동적 계획법, DP)</h2>
                                <div class="box-info">
                                    <p class="category">? Archive/Algorithm</p>
                                    <p class="date">2021-07-25 18:59:51</p>
                                </div>
                            </div>
                        </div>
                    </div>
                    <hr>
                    <div class="article-view">
                        <div class="contents_style">
                            <p><figure class="imageblock alignCenter" data-origin-width="1091" data-origin-height="213" data-ke-mobilestyle="widthOrigin">
    <span data-lightbox="lightbox">
        <img src="./img/img.png" data-origin-width="1091" data-origin-height="213" data-ke-mobilestyle="widthOrigin" />
    </span>
    <figcaption></figcaption>
</figure></p>
<p style="text-align: center;" data-ke-size="size18"><span style="font-family: 'Nanum Gothic'; color: #ffffff; background-color: #333333;">[목차]</span></p>
<p style="text-align: center;" data-ke-size="size18"><b><span style="font-family: 'Nanum Gothic'; color: #000000;">#1 동적 계획법 (Dynamic Programming)</span></b></p>
<p style="text-align: center;" data-ke-size="size18"><b><span style="font-family: 'Nanum Gothic'; color: #000000;">#2 동적 계획법의 특징</span></b></p>
<p style="text-align: center;" data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;">*2.1 Overlaping SubProblem 겹치는 부분 문제</span></p>
<p style="text-align: center;" data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;">*2.1 Optimal Structure 최적 부분구조</span></p>
<p style="text-align: center;" data-ke-size="size18"><b><span style="font-family: 'Nanum Gothic'; color: #000000;">#3 동적 계획법 구현 방법</span></b></p>
<p style="text-align: center;" data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;">*3.1 Top - down : 재귀</span></p>
<p style="text-align: center;" data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;">*3.2 Bottom - up : 반복</span></p>
<p style="text-align: center;" data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000; background-color: #f6e199;">* 개인적인 공부 내용을 기록한 글 이기에 잘못된 내용을 포함하고 있을 수 있습니다.</span></p>
<hr contenteditable="false" data-ke-type="horizontalRule" data-ke-style="style5" />
<h2 data-ke-size="size26"><b><span style="font-family: 'Noto Serif KR'; color: #000000;">#1 동적 계획법 (Dynamic Programming)</span></b></h2>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;"><span style="background-color: #333333; color: #ffffff;">다이나믹 프로그래밍 (Dynamic Programming)</span> 즉, 동적 계획법은 <span style="background-color: #333333; color: #ffffff;">큰 문제 (Big Problem) 를 작은 문제 (Small Problem) 로 나누어 해결하는 아이디어를 활용한 알고리즘 기법</span>이다.</span></p>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;">이는 마치 분할 정복 (Divide &amp; Conquer) 방식과 비슷한데, <b>분할 정복과 다른 점은 다이나믹 프로그래밍 에서는 작은 문제가 중복되지만 분할 정복은 중복되지 않는다는 것이다.</b></span></p>
<hr contenteditable="false" data-ke-type="horizontalRule" data-ke-style="style5" />
<h2 data-ke-size="size26"><b><span style="font-family: 'Noto Serif KR'; color: #000000;">#2 동적 계획법의 특징</span></b></h2>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;">동적 계획법 관련 알고리즘 문제들은 다음 2가지 특성을 가지고 있다.</span></p>
<h3 data-ke-size="size23"><span style="font-family: 'Noto Serif KR'; color: #ffffff; background-color: #333333;">*2.1 Overlaping SubProblem 겹치는 부분(작은) 문제</span></h3>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #ffffff; background-color: #333333;">Overlaping SubProblem 이란 큰 문제 (Big Problem) 를 작은 문제 (Small Problem) 으로 쪼갤 때 작은 문제가 여러 번 재 사용 되는 것을 의미한다. </span></p>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;">대표적인 예시로 피보나치 수열이 있는데, 피보나치 수열이란 앞의 두 수를 더한 수가 다음 수가 되는 수열이다.</span></p>
<p><figure class="imageblock alignLeft" data-origin-width="425" data-origin-height="78" width="316" height="58" data-ke-mobilestyle="widthOrigin">
    <span data-lightbox="lightbox">
        <img src="./img/img_1.png" data-origin-width="425" data-origin-height="78" width="316" height="58" data-ke-mobilestyle="widthOrigin" />
    </span>
    <figcaption></figcaption>
</figure></p>
<pre id="code_1627206033000" class="c++ arduino" data-ke-language="c++" data-ke-type="codeblock"><code>int fibonacci (int n) {
	if (n &lt;= 1){
		return n;
	}
	else{
		return fibonachi(n-1) + fibonachi(n-2);
	}
}</code></pre>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;">F(n) = F(n-1) + F(n-2) 이고 F(n-1) = F(n-2) + F(n-3) , F(n-2) = F(n-3) + F(n-4) 로 다시 나뉘어 진다. (Fn = 큰문제 , F(n-1) F(n-2) = 작은 문제)</span></p>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;">식을 자세히 보면, F(n-2)과 F(n-3) 이 2번 씩 겹친다. 이 것이 바로 Overlaping SubProblem(겹치는 부분 문제)의 상황이다.</span></p>
<p data-ke-size="size16">&nbsp;</p>
<h3 data-ke-size="size23"><span style="font-family: 'Noto Serif KR'; color: #ffffff; background-color: #333333;">*2.2 Optimal Substructure (최적 부분구조)</span></h3>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;"><span style="color: #000000;"><span style="background-color: #333333; color: #ffffff;">Optimal Substructure(최적 부분구조)란, 큰 문제의 정답을 작은 문제를 통해 풀이하는 것</span>을 의미한다.</span></span></p>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;"><span style="color: #000000;">A지점에서 F지점까지 가는 3가지 루트가 존재 한다고 가정해 보자.</span></span></p>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;"><span style="color: #000000;">1번 루트는 A C F (15) 2번 루트는 A B E (7) 3번 루트는 A D F (17) 이다. 이 때 A에서 F까지 가는 최적의 루트는 A B E F 이다.</span></span></p>
<p><figure class="imageblock alignLeft" data-origin-width="475" data-origin-height="303" width="378" height="241" data-ke-mobilestyle="widthOrigin">
    <span data-lightbox="lightbox">
        <img src="./img/img_2.png" data-origin-width="475" data-origin-height="303" width="378" height="241" data-ke-mobilestyle="widthOrigin" />
    </span>
    <figcaption></figcaption>
</figure></p>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;">이제 B지점에서 F지점으로 가는 최적의 루트를 구해보자. B E F (5) 루트가 최적의 루트일 것이다.</span></p>
<p><figure class="imageblock alignLeft" data-origin-width="475" data-origin-height="303" width="370" height="236" data-ke-mobilestyle="widthOrigin">
    <span data-lightbox="lightbox">
        <img src="./img/img_3.png" data-origin-width="475" data-origin-height="303" width="370" height="236" data-ke-mobilestyle="widthOrigin" />
    </span>
    <figcaption></figcaption>
</figure></p>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;">A 지점에서 F 지점으로 가는 최적의 루트 문제를 큰 문제 (Big Problem) B 지점에서 F 지점으로 가는 최적의 루트 문제를 작은 문제 (Small Problem) 이라고 가정한다면, 작은 문제 (B ~ F)로 큰 문제 (A ~ F) 의 답을 유추할 수 있다.</span></p>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;">이처럼 <span style="background-color: #333333; color: #ffffff;">Optimal Substructure를 만족하면, 문제의 크기에 관계없이 특정 문제에 대한 정답은 항상 일치한다.</span></span></p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;">Optimal Substructure의 또 다른 예시로 피보나치 수열을 예시로 들어 보겠다.</span></p>
<p><span style="color: #000000;">피보나치 5는 작은 문제인 피보나치4와 피보나치3으로 나눌 수 있고, 피보나치5의 피보나치 3 값과 피보나치 4의 피보나치 3 값은 일치할 것이다. 따라서 피보나치 수열은 Optimal SubStructure 를 만족한다.</span><figure class="imageblock alignLeft" data-origin-width="426" data-origin-height="386" width="316" height="286" data-ke-mobilestyle="widthOrigin">
    <span data-lightbox="lightbox">
        <img src="./img/img_4.png" data-origin-width="426" data-origin-height="386" width="316" height="286" data-ke-mobilestyle="widthOrigin" />
    </span>
    <figcaption></figcaption>
</figure></p>
<hr contenteditable="false" data-ke-type="horizontalRule" data-ke-style="style5" />
<h2 data-ke-size="size26"><b><span style="font-family: 'Noto Serif KR'; color: #000000;">#3 동적 계획법 구현 방법</span></b></h2>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;">동적 계획법을 구현하는 방법은 큰 문제에서 작은 문제로 내려가는 <span style="background-color: #333333; color: #ffffff;">재귀를 이용한 Top - down 방식</span>과 작은 문제로 부터 큰 문제로 올라가는 <span style="background-color: #333333; color: #ffffff;">반복문을 이용한 Bottom - up 방식</span>으로 나뉜다.</span></p>
<h3 data-ke-size="size23"><span style="font-family: 'Noto Serif KR'; color: #ffffff; background-color: #333333;">*3.1 Top - down : 재귀</span></h3>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;">Top - down 방식의 핵심은 <span style="background-color: #333333; color: #ffffff;">1. 문제를 작은 문제로 나누고 2. 작은 문제를 풀고 3. 풀이한 작은 문제를 바탕으로 큰 문제를 푸는 사고</span> 이다. <span style="color: #000000;">아래는 Top - down 방식을 이용해 피보나치를 구현한 코드이다.<span>&nbsp;</span></span></span></p>
<pre id="code_1627206201507" class="c++ arduino" data-ke-language="c++" data-ke-type="codeblock"><code>int memo[1001];
int fibonacci (int n) {
	if (n &lt;= 1){
		return n;
	}
	else{
		// 큰 문제를 작은 문제로 나누고 메모한다.
        memo[n] = fibonacci(n-1) + fibonacci(n-2);
		return memo[n];
	}
}</code></pre>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;"><span style="background-color: #333333; color: #ffffff;">어떠한 정답을 구하면 그 정답을 메모해 두고 메모를 이용하는 방식</span>을 <span style="background-color: #333333; color: #ffffff;">메모리제이션(Memorization)</span> 이라고 부른다.</span></p>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;">단지 코드가 한 줄 추가됐을 뿐인데, 코드의 효율은 눈에 띄게 증가한다.</span></p>
<p><span style="color: #000000;">Top - down 재귀를 이용한 방식은 시간복잡도가 O(N)이고, 일반적인 피보나치 소스코드는 시간복잡도가 O(2^n)이다.</span></p>
<p data-ke-size="size16">&nbsp;</p>
<h3 data-ke-size="size23"><span style="font-family: 'Noto Serif KR'; color: #ffffff; background-color: #333333;">*3.2 Bottom - up : 반복</span></h3>
<p><span style="color: #000000;">Bottom - up 방식의 사고는 <span style="background-color: #333333; color: #ffffff;">1. 크기가 작은 문제부터 차례로 풀고 2. 문제를 크게 만들어 나가며 풀이하고 3. 이 과정을 계속 반복하면 원하는 큰 문제를 풀 수 있다. 는 사고</span>이다.</span><span style="color: #000000;">다음은 Bottom - up 방식을 이용해 피보나치를 구현한 코드이다.</span></p>
<pre id="code_1627206547537" class="c++ arduino" data-ke-language="c++" data-ke-type="codeblock"><code>int dp[1001];
int fibonacci (int n) {
	
	// 작은 문제를 푼다. 
	dp[0] = 0;
	dp[1] = 1;

	// 풀이한 작은 문제를 바탕으로 반복한다. 
	for (int i = 2 ; i &lt;= n ; i++){
		d[i] = d[i-1] + d[i-2];
	}
	return d[n]
}</code></pre>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;">그렇다면 Top-down Bottom-up 방식 중 어떤 방법을 사용하는 것이 더 효율적일까?</span></p>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;">정답은 알 수 없다. 문제의 상황에 따라 달라지고 유의미한 차이는 아니니, 둘다 시간 복잡도를 O(N) 이라고 생각하면 된다.</span></p>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;">하지만 예외로 Python으로 알고리즘 문제를 풀이하는 경우에는 Top - down 방식은 스택 오버플로우 (Stack OverFlow) 가 발생할 위험이 있어서 지양되지만, C++ 이나 JAVA 와 같은 언어는 어떤 방식을 사용하던 상관이 없다.<span>&nbsp;</span></span><span style="font-family: 'Nanum Gothic'; color: #000000;">따라서 자신의 스타일에 맞는 방식을 하나 채택하여 연습해 나가면 된다.</span></p>
<hr contenteditable="false" data-ke-type="horizontalRule" data-ke-style="style5" />
                        </div>
                        <br/>
                        <div class="tags">
                            #Dynamic #피보나치수열 #동적계획법 #다이나믹프로그래밍 #알고리즘강의 #최적부분구조 #겹치는부분문제 
                        </div>
                    </div>
                </div>
            </div>
        </main>
    </div>
</div>
</body>
</html>
