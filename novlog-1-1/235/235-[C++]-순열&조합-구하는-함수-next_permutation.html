
<meta charset="utf-8">
<html lang="ko">
<head>
    <link rel="stylesheet" type="text/css" href="./../style.css" />
    <title>[C++] 순열&조합 구하는 함수 next_permutation</title>
</head>
<body id="tt-body-page" class="">
<div id="wrap" class="wrap-right">
    <div id="container">
        <main class="main ">
            <div class="area-main">
                <div class="area-view">
                    <div class="article-header">
                        <div class="inner-article-header">
                            <div class="box-meta">
                                <h2 class="title-article">[C++] 순열&조합 구하는 함수 next_permutation</h2>
                                <div class="box-info">
                                    <p class="category">? Archive/C&C++</p>
                                    <p class="date">2022-06-14 23:16:37</p>
                                </div>
                            </div>
                        </div>
                    </div>
                    <hr>
                    <div class="article-view">
                        <div class="contents_style">
                            <p><figure class="imageblock alignCenter" >
    <span data-lightbox="lightbox">
        <img src="./img/img.png"  />
    </span>
    <figcaption></figcaption>
</figure></p>
<p style="text-align: center;" data-ke-size="size18"><span style="font-family: 'Nanum Gothic'; color: #dddddd; background-color: #333333;">[C++] next/prev_permutation</span></p>
<p style="text-align: center;" data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;">* 개인적인 공부 내용을 기록하는 용도로 작성한 글 이기에 <span style="color: #781b33;"><u><b>잘못된 내용을 포함하고 있을 수 있습니다.</b></u></span></span></p>
<p style="text-align: center;" data-ke-size="size16">&nbsp;</p>
<p style="text-align: center;" data-ke-size="size18"><span style="font-family: 'Nanum Gothic'; color: #dddddd; background-color: #333333;">_contents</span></p>
<p style="text-align: center;" data-ke-size="size16"><b><span style="font-family: 'Nanum Gothic'; color: #000000;">#1 순열이란?</span></b></p>
<p style="text-align: center;" data-ke-size="size16"><b><span style="font-family: 'Nanum Gothic'; color: #000000;">#2 next_permutation</span></b></p>
<p style="text-align: center;" data-ke-size="size16"><b><span style="font-family: 'Nanum Gothic'; color: #000000;">#3 주의점</span></b></p>
<p style="text-align: center;" data-ke-size="size16"><b><span style="font-family: 'Nanum Gothic'; color: #000000;">#4 조합 구현하기</span></b></p>
<p style="text-align: center;" data-ke-size="size16">&nbsp;</p>
<p style="text-align: center;" data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #dddddd; background-color: #333333;">_Fix</span></p>
<p style="text-align: center;" data-ke-size="size16"><b><span style="font-family: 'Nanum Gothic'; color: #000000;">&rarr; 2022-09-11 #4 조합 구현하기 추가</span></b></p>
<hr contenteditable="false" data-ke-type="horizontalRule" data-ke-style="style5" />
<h2 style="text-align: left;" data-ke-size="size26"><span style="color: #1a5490;"><b><span style="font-family: 'Nanum Gothic';">#1 순열과 조합</span></b></span></h2>
<p style="text-align: left;" data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;"><span style="background-color: #333333; color: #dddddd;">순열[permutation]</span>이란 <b>순서가 부여된 서로 다른 n개의 원소에서 r개의 원소를 뽑아 한 줄로 세우는 모든 경우의 수</b>를 의미한다.&nbsp;</span></p>
<p style="text-align: left;" data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;">예를 들어 <b>{1, 2, 3}</b> 집합의 원소들의 모든 <b>순열</b>을 구하면 다음과 같다.</span></p>
<p style="text-align: left;" data-ke-size="size16"><b><span style="font-family: 'Nanum Gothic'; color: #000000;">{1, 2, 3} {1, 3, 2} {2, 1, 3} {2, 3, 1} {3, 1, 2} {3, 2, 1}</span></b></p>
<p style="text-align: left;" data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;">이러한 순열을 기호로 나타내는 경우 영어 Permutation의 첫 글자 P를 이용해 nPr 이라고 한다.</span><span style="font-family: 'Nanum Gothic'; color: #000000;"></span></p>
<p style="text-align: left;" data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;"><span style="background-color: #333333; color: #dddddd;">nPr</span>이란 서로 다른 <b>n개의 원소 중에서 r개를 뽑아 줄을 세운다</b>는 뜻이다.&nbsp;</span></p>
<p style="text-align: left;" data-ke-size="size16">&nbsp;</p>
<p style="text-align: left;" data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;"><span style="background-color: #333333; color: #dddddd;">조합[Combination]</span>이란 <b>순서가 부여되지 않은 n개의 원소에서 r개의 원소를 뽑아 한 줄로 세우는 모든 경우의 수</b>를 의미한다.</span></p>
<p style="text-align: left;" data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;">앞에서 순열은 {1, 2, 3}과 {1, 3, 2}를 다른 케이스로 계산했지만, 조합은 같은 케이스로 다룬다. 따라서&nbsp;</span></p>
<p style="text-align: left;" data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;"><b>{1, 2, 3} 집합의 원소들 중에서 2개의 원소를 뽑는 조합</b>을 구하면 다음과 같다.</span></p>
<p style="text-align: left;" data-ke-size="size16"><b><span style="font-family: 'Nanum Gothic'; color: #000000;">{1, 2} {1, 3} {2, 3}</span></b></p>
<p style="text-align: left;" data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;">조합을 기호로 나타낼 때 영어 Combination의 첫 글자 C를 이용해 nCr과 같이 나타낸다.</span></p>
<p style="text-align: left;" data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;"><span style="background-color: #333333; color: #dddddd;">nCr</span>이란 순서가 부여되지 않은 n개의 원소 중 r개의 원소를 뽑아 줄을 세운다는 의미이다.&nbsp;</span></p>
<p style="text-align: left;" data-ke-size="size16">&nbsp;</p>
<p style="text-align: left;" data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;">순열과 조합을 직접 구현할 수 도 있지만 코딩테스트에서 순열/조합 알고리즘을 하나하나 구현 하고 있는 것은 비효율적이다.</span></p>
<p style="text-align: left;" data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;"><span style="background-color: #333333; color: #dddddd;">C++ STL &lt;algorithm&gt;</span> 헤더의 <span style="background-color: #333333; color: #dddddd;">next_permutation</span> 함수를 사용하면 순열과 조합의 경우의 수를 손쉽게 구할 수 있다.</span></p>
<hr contenteditable="false" data-ke-type="horizontalRule" data-ke-style="style5" />
<h2 style="text-align: left;" data-ke-size="size26"><span style="color: #1a5490;"><b><span style="font-family: 'Nanum Gothic';">#2 next_permutation</span></b></span></h2>
<pre id="code_1662892331736" class="cpp" data-ke-language="cpp" data-ke-type="codeblock"><code>#include &lt;algorithm&gt;</code></pre>
<pre id="code_1655215177863" class="cpp" data-ke-language="cpp" data-ke-type="codeblock"><code>bool&nbsp;next_permutation&nbsp;(BidirectionalIterator&nbsp;first, BidirectionalIterator&nbsp;last);</code></pre>
<p data-ke-size="size16"><span style="color: #000000; font-family: 'Nanum Gothic';">* STL <span style="background-color: #333333; color: #dddddd;">&lt;algorithm&gt;</span> 헤더에서 C++11 버전 이후부터 제공한다.</span></p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size18"><span style="font-family: 'Nanum Gothic'; color: #1a5490;"><b>Parameters</b></span></p>
<p style="text-align: left;" data-ke-size="size16">&nbsp;</p>
<p style="text-align: left;" data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;"><span style="background-color: #333333; color: #dddddd;">next_permutation</span> 함수는 <b>순열을 구할 ①시작과 끝의 iterator</b> 혹은 배열의 경우<b> ②시작과 끝의 주소</b>를 입력받는다.</span></p>
<p style="text-align: left;" data-ke-size="size16">&nbsp;</p>
<p style="text-align: left;" data-ke-size="size18"><span style="color: #1a5490;"><b><span style="font-family: 'Nanum Gothic';">Return Value</span></b></span></p>
<p style="text-align: left;" data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;"><b>현재 탐색하고 있는 순열의 다음 순열을 구하고 <span style="background-color: #dddddd;">true</span>를 반환</b>한다. </span></p>
<p style="text-align: left;" data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;"><b>만약 다음 순열이 존재하지 않는다면 <span style="background-color: #dddddd;">false</span>를 반환</b>한다.</span></p>
<p style="text-align: left;" data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;">즉, 마지막 모든 순열의 경우의 수를 탐색한 뒤, false를 반환한다.&nbsp;</span></p>
<p style="text-align: left;" data-ke-size="size16">&nbsp;</p>
<p style="text-align: left;" data-ke-size="size18"><b><span style="font-family: 'Nanum Gothic'; color: #1a5490;">Example</span></b></p>
<p style="text-align: left;" data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;">다음은 {1, 2, 3} 집합을 next_permutation 함수를 사용해 집합의 모든 조합을 구한 예제이다.</span></p>
<pre id="code_1655215364024" class="cpp" data-ke-language="cpp" data-ke-type="codeblock"><code>#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt; // next_permutation
using namespace std;

int main(){
	//INPUT
	// vector v 1 ~ 3 까지의 원소를 대입
	vector&lt;int&gt; v(3);
	for(int i = 0; i &lt; 3; ++i)
		v[i] = i + 1;
	
	// next_permutation
	do{
		for(int i = 0; i &lt; 3; ++i)
			cout &lt;&lt; v[i] &lt;&lt; " ";
		cout &lt;&lt; '\n';
	}while(next_permutation(v.begin(), v.end()));
	
	return 0;
}</code></pre>
<pre id="code_1655215423502" class="bash" data-ke-language="bash" data-ke-type="codeblock"><code>[출력결과]
1 2 3
1 3 2
2 1 3
2 3 1
3 1 2
3 2 1</code></pre>
<hr contenteditable="false" data-ke-type="horizontalRule" data-ke-style="style5" />
<h2 data-ke-size="size26"><span style="color: #1a5490;"><b><span style="font-family: 'Nanum Gothic';">#3 주의점</span></b></span></h2>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;">next_permutation 함수를 사용할 때 주의 해야할 사항이 있다.</span></p>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #dddddd; background-color: #333333;">모든 순열의 경우의 수를 탐색하기 위해서는 반드시 사전에 배열 혹은 벡터를 미리 정렬해 두어야 한다.</span></p>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;">next_permutation 함수는 <b>이전 크기의 순열의 조합은 탐색하지 않는다.</b> 예를들어 벡터 안의 원소가 {2, 3, 1} 로 정렬 되어 있다고 가정해 보자.</span></p>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;">{2, 3, 1} 벡터를 next_permutaiton 함수를 사용해 모든 순열을 출력해 보면 {2, 3, 1} {3, 1, 2} {3, 2, 1} 만을 탐색하고 앞부분 {1, 2, 3} {1, 3, 2} {2, 1, 3} 은 탐색하지 않는다.</span></p>
<pre id="code_1655215719494" class="bash" data-ke-language="bash" data-ke-type="codeblock"><code>#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt; // next_permutation
using namespace std;

int main(){
	//INPUT
	vector&lt;int&gt; v(3);
	v[0] = 2;
	v[1] = 3;
	v[2] = 1;
	
	// next_permutation
	do{
		for(int i = 0; i &lt; 3; ++i)
			cout &lt;&lt; v[i] &lt;&lt; " ";
		cout &lt;&lt; '\n';
	}while(next_permutation(v.begin(), v.end()));
	
	return 0;
}</code></pre>
<pre id="code_1655215736294" class="bash" data-ke-language="bash" data-ke-type="codeblock"><code>[출력결과]
2 3 1
3 1 2
3 2 1</code></pre>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;">따라서 모든 순열의 경우의 수를 구하고 싶다면 다음과 같이 <span style="background-color: #333333; color: #dddddd;">sort 함수</span>를 이용해 미리 오름차 정렬한 뒤 next_permutation 함수를 적용 하는 것을 권장한다.</span></p>
<pre id="code_1655216134946" class="cpp" data-ke-language="cpp" data-ke-type="codeblock"><code>#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt; // next_permutation &amp; sort
using namespace std;

int main(){
	//INPUT
	vector&lt;int&gt; v = {2, 3, 1};
	
	sort(v.begin(), v.end());
	// next_permutation
	do{
		for(int i = 0; i &lt; 3; ++i)
			cout &lt;&lt; v[i] &lt;&lt; " ";
		cout &lt;&lt; '\n';
	}while(next_permutation(v.begin(), v.end()));
	
	return 0;
}</code></pre>
<pre id="code_1655216153417" class="bash" data-ke-language="bash" data-ke-type="codeblock"><code>[출력결과]
1 2 3
1 3 2
2 1 3
2 3 1
3 1 2
3 2 1</code></pre>
<hr contenteditable="false" data-ke-type="horizontalRule" data-ke-style="style5" />
<h2 data-ke-size="size26"><span style="color: #1a5490;"><b><span style="font-family: 'Nanum Gothic';">#4 조합 구현하기</span></b></span></h2>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;"><span style="background-color: #333333; color: #dddddd;">next_permutation</span> 함수와 <span style="background-color: #333333; color: #dddddd;">보조수열</span>을 이용해 조합을 구현할 수 있다.&nbsp;</span></p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;">next_permutation 함수를 이용해 nCr을 구하는 알고리즘은 다음과 같다.</span></p>
<p data-ke-size="size16"><span style="background-color: #dddddd;"><b><span style="font-family: 'Nanum Gothic'; color: #000000;">1. 전체 길이가 n , 1의 개수가 r , 나머지가 0으로 채워진 보조 수열을 생성한다. (단, 1은 뒤에서 부터 채워져 있어야 한다.)</span></b></span></p>
<p data-ke-size="size16"><span style="background-color: #dddddd;"><b><span style="font-family: 'Nanum Gothic'; color: #000000;">2. 보조수열에 대한 조합을 모든 순열을 구한다.&nbsp;</span></b></span></p>
<p data-ke-size="size16"><span style="background-color: #dddddd;"><b><span style="font-family: 'Nanum Gothic'; color: #000000;">3. 보조수열을 순회하며 index가 1인 위치와 일치하는 원래 수열의 인덱스의 값을 출력한다.&nbsp;</span></b></span></p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;">예를들어 {1, 2, 3, 4} 배열의 원소들 중에서 2개의 원소를 택하여 조합을 구하고 싶다면 즉, 4C2를 구현하고자 한다면 보조 수열을 다음과 같이 작성하면 된다.</span></p>
<pre id="code_1662895810661" class="cpp" data-ke-language="cpp" data-ke-type="codeblock"><code>	vector&lt;int&gt; v {1, 2, 3, 4};
	// visited - 보조수열
	vector&lt;int&gt; visit {0, 0, 1, 1};</code></pre>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;">이 때 보조수열의 1은 뒤에서 부터 채워져 있어야 하는데, 이는 앞에서 설명한 바와 마찬가지로 <b>next_permutation 함수는 </b><b>오름차로 정렬되어 있지 않으면&nbsp; 앞 순서의 순열을 무시한다는 특성</b>&nbsp;때문이다.&nbsp;</span></p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;">다음으로 보조수열을 next_permutation 함수를 이용해 순회하며 인덱스가 1인 경우에만 원래 수열의 원소를 출력해 주면 된다.</span></p>
<pre id="code_1662895972862" class="cpp" data-ke-language="cpp" data-ke-type="codeblock"><code>	do{
		for(int i = 0; i &lt; v.size(); ++i)
			if(visit[i] != 0)
				cout &lt;&lt; v[i] &lt;&lt; " ";
		cout &lt;&lt; '\n';
	}while(next_permutation(visit.begin(), visit.end()));</code></pre>
<pre id="code_1662895984702" class="cpp" data-ke-language="cpp" data-ke-type="codeblock"><code>3 4
2 4
2 3
1 4
1 3
1 2</code></pre>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;">원리는 간단하다.</span></p>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;">보조수열의 순열을 쭉 나열해보면 다음과 같다.&nbsp;</span></p>
<pre id="code_1662896103810" class="cpp" data-ke-language="cpp" data-ke-type="codeblock"><code>	vector&lt;int&gt; visit {0, 0, 1, 1};
	do{
		for(int i = 0; i &lt; visit.size(); ++i)
			cout &lt;&lt; visit[i] &lt;&lt; " ";
		cout &lt;&lt; '\n';
	}while(next_permutation(visit.begin(), visit.end()));</code></pre>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;">next_permutaiton 함수는 <b>"중복을 제외한"</b> 조합을 구하는 함수이기에</span></p>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;"><b>"중복을 제외한" 보조순열에 대한 모든 케이스,</b> 총 <span style="background-color: #dddddd;">6가지</span>가 출력된다.</span></p>
<pre id="code_1662896110405" class="cpp" data-ke-language="cpp" data-ke-type="codeblock"><code>0 0 1 1
0 1 0 1
0 1 1 0
1 0 0 1
1 0 1 0
1 1 0 0</code></pre>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;">이제 여기서 보조수열의 인덱스가 1인 위치와 원래 구하고자 하는 배열의 원소와 비교해보면?</span></p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;">1&nbsp;2&nbsp;3&nbsp;4 </span><br /><span style="font-family: 'Nanum Gothic'; color: #000000;">---------</span><br /><span style="font-family: 'Nanum Gothic'; color: #000000;">0 0 <b>1 1</b> ... <b>3 4</b></span><br /><span style="font-family: 'Nanum Gothic'; color: #000000;">0&nbsp;<b>1</b>&nbsp;0&nbsp;<b>1 ... </b>2 4</span><br /><span style="font-family: 'Nanum Gothic'; color: #000000;">0&nbsp;<b>1&nbsp;1</b> 0 ... 2 3</span><br /><span style="font-family: 'Nanum Gothic'; color: #000000;"><b>1</b>&nbsp;0&nbsp;0&nbsp;<b>1 ... </b>1 4</span><br /><span style="font-family: 'Nanum Gothic'; color: #000000;"><b>1</b>&nbsp;0&nbsp;<b>1</b> 0 ... 1 3</span><br /><span style="font-family: 'Nanum Gothic'; color: #000000;"><b>1&nbsp;1</b> 0 0 ... 1 2</span></p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;">4C2 총 6가지의 순열이 출력되게 되는 것이다.</span></p>
<hr contenteditable="false" data-ke-type="horizontalRule" data-ke-style="style5" />
                        </div>
                        <br/>
                        <div class="tags">
                            #C++ #STL #순열 #next_permutation #prev_permutation 
                        </div>
                    </div>
                </div>
            </div>
        </main>
    </div>
</div>
</body>
</html>
