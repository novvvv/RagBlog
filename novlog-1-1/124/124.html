
<meta charset="utf-8">
<html lang="ko">
<head>
    <link rel="stylesheet" type="text/css" href="./../style.css" />
    <title>[GameAlgorithm] 미로 생성 알고리즘 _ Binary Tree Maze Algorithm</title>
</head>
<body id="tt-body-page" class="">
<div id="wrap" class="wrap-right">
    <div id="container">
        <main class="main ">
            <div class="area-main">
                <div class="area-view">
                    <div class="article-header">
                        <div class="inner-article-header">
                            <div class="box-meta">
                                <h2 class="title-article">[GameAlgorithm] 미로 생성 알고리즘 _ Binary Tree Maze Algorithm</h2>
                                <div class="box-info">
                                    <p class="category">? Archive/Algorithm</p>
                                    <p class="date">2021-08-22 22:09:31</p>
                                </div>
                            </div>
                        </div>
                    </div>
                    <hr>
                    <div class="article-view">
                        <div class="contents_style">
                            <p style="text-align: center;" data-ke-size="size18"><b><span style="color: #000000; font-family: 'Nanum Gothic';">[목차]</span></b></p>
<p style="text-align: center;" data-ke-size="size18"><b><span style="color: #000000; font-family: 'Nanum Gothic';">#Binary Tree Maze Algorithm&nbsp;</span></b></p>
<p style="text-align: center;" data-ke-size="size18"><b><span style="color: #000000; font-family: 'Nanum Gothic';">#구현</span></b></p>
<p style="text-align: center;" data-ke-size="size18"><b><span style="color: #000000; font-family: 'Nanum Gothic';">#참고</span></b></p>
<p style="text-align: center;" data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #ffffff; background-color: #333333;">* 개인적인 공부 내용을 기록하기 위한 용도로 작성된 포스팅 이기에 잘못된 내용이 있을 수 있습니다.</span></p>
<p style="text-align: center;" data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #ffffff; background-color: #333333;">* 인프런 Rookiss 선생님의 PART2 자료구조와 알고리즘 - Binary Tree 미로 생성 알고리즘 내용을 기반으로 정리한 글 입니다.</span></p>
<hr contenteditable="false" data-ke-type="horizontalRule" data-ke-style="style5" />
<h2 data-ke-size="size26"><span style="font-family: 'Noto Serif KR'; color: #000000;">#Binary Tree Maze Algorithm&nbsp;</span></h2>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;"><span style="background-color: #333333; color: #ffffff;">Binary Tree Maze Algorithm</span> 이란, 간단한 미로 생성 알고리즘 중 하나로 모<span style="background-color: #f6e199;">든 벽이 막힌 정사각형 모양이 보드판이 있다고 가정할 때 오른쪽 혹은 아래쪽 (위쪽 혹은 왼쪽도 가능) 으로 길을 뚫어 가며 미로를 생성하는 원리의 알고리즘</span>이다.</span></p>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;">예를들어 다음과 같은 5X5 타일이 준비되어 있으며, 좌측 상단부터 미로를 생성해 나간다고 생각해 보자.</span></p>
<p><figure class="imageblock alignLeft" data-origin-width="220" data-origin-height="290" data-ke-mobilestyle="widthOrigin">
    <span data-lightbox="lightbox">
        <img src="./img/img.png" data-origin-width="220" data-origin-height="290" data-ke-mobilestyle="widthOrigin" />
    </span>
    <figcaption></figcaption>
</figure></p>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;">선택한 블록으로 부터 오른쪽 혹은 아래쪽으로 1/2 의 랜덤확률로 길을 뚫어서 미로를 생성해 나간다.</span></p>
<p><figure class="imageblock alignLeft" data-origin-width="702" data-origin-height="290" data-ke-mobilestyle="widthOrigin">
    <span data-lightbox="lightbox">
        <img src="./img/img_1.png" data-origin-width="702" data-origin-height="290" data-ke-mobilestyle="widthOrigin" />
    </span>
    <figcaption></figcaption>
</figure></p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;"><span style="background-color: #f6e199;">구현이 쉽고 간단하다</span>는 장점이 이지만, <span style="background-color: #ffc1c8;">모양이 치우쳐저서 맵이 이쁘게 나오지 않는다는 단점</span>이 있다.</span></p>
<hr contenteditable="false" data-ke-type="horizontalRule" data-ke-style="style5" />
<h2 data-ke-size="size26"><span style="font-family: 'Noto Serif KR'; color: #000000;">#구현</span></h2>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;">들어가기에 앞서 몇가지 Console 클래스의 메서드를 소개한다. <span style="background-color: #333333; color: #ffffff;">Console 클래스</span>는 <b>콘솔 애플리케이션에 대한 표준 입력, 출력 및 오류 스트림을 나타내는 클래스이다.&nbsp;</b></span></p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;"><b>Console.CursorVisible</b> : 커서의 깜빡거림을 꺼주는 기능을 수행한다. bool 값을 넣어 주며 true = 킴 false = 끔 상태이다.</span></p>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;"><b>Console.setCursorPosition(X,Y)</b> : 커서의 위치를 X, Y 지점으로 옮겨준다.</span></p>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;"><b>ConsoleColor</b> : 콘솔의 전경색과 배경색을 정의하는 상수를 지정한다.</span></p>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;"><b>Console.ForegroundColor</b> : 콘솔의 전경색을 가져오거나 설정한다. (Default Value : Gray)</span></p>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;">더 자세한 내용은&nbsp;</span> <a href="https://docs.microsoft.com/ko-kr/dotnet/api/system.console?view=net-5.0">https://docs.microsoft.com/ko-kr/dotnet/api/system.console?view=net-5.0</a> <span style="color: #000000; font-family: 'Nanum Gothic';">를 참고 하도록 하자!</span></p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;">다음 프로젝트에는 프로그램 메인부분인 Program.cs 와 미로의 출력 및 미로 생성 알고리즘 함수가 정의되어 있는는 Board.cs 2가지 소스파일이 사용 되었다.</span></p>
<pre id="code_1629636450255" class="cs" data-ke-language="cs" data-ke-type="codeblock"><code>// Program.cs
using System;

namespace Algorithm
{
    class Program
    {
        static void Main(string[] args)
        {
            Board board = new Board();
            board.Initialize(25);
            Console.CursorVisible = false;

            while (true)
            {
                Console.SetCursorPosition(0,0);
                board.Render();
            }
        }
    }
}</code></pre>
<pre id="code_1629636538291" class="cs" data-ke-language="cs" data-ke-type="codeblock"><code>// Board.cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Algorithm
{
    class Board
    {
        const char CIRCLE = '\u25cf';
        public TileType[,] _tile;
        public int _size;

        public enum TileType
        {
            Empty,
            Wall,
        }

        public void Initialize(int size)
        {
            // Exception
            if (size % 2 == 0)
                return;

            _tile = new TileType[size, size];
            _size = size;

            GenerateByBinaryTree();
        }

        void GenerateByBinaryTree()
        {
            // Mazes for Programmers - Binary Tree Algorithm
            // 초기 맵 설정
            for (int y = 0; y &lt; _size; y++)
            {
                for (int x = 0; x &lt; _size; x++)
                {
                    if (x % 2 == 0 || y % 2 == 0)
                        _tile[y, x] = TileType.Wall;
                    else
                        _tile[y, x] = TileType.Empty;
                }
            }

            // Random 길뚫기
            Random rand = new Random();
            for (int y = 0; y &lt; _size; y++)
            {
                for (int x = 0; x &lt; _size; x++)
                {
                    if (x % 2 == 0 || y % 2 == 0)
                        continue;

                    // 보완 //
                    if (y == _size - 2)
                    {
                        _tile[y, x + 1] = TileType.Empty;
                        continue;
                    }

                    if (x == _size - 2)
                    {
                        _tile[y + 1, x] = TileType.Empty;
                        continue;
                    }
                    // 보완 //

                    if (rand.Next(0, 2) == 0)
                    {
                        _tile[y, x + 1] = TileType.Empty;
                    }
                    else
                    {
                        _tile[y + 1, x] = TileType.Empty;
                    }
                }
            }
        }

        public void Render()
        {
            ConsoleColor prevColor = Console.ForegroundColor; 

            for (int y = 0; y &lt; _size; y++)
            {
                for (int x = 0; x &lt; _size; x++)
                {
                    Console.ForegroundColor = GetTileColor(_tile[y, x]);                  
                    Console.Write(CIRCLE);
                }
                Console.WriteLine();
            }

            Console.ForegroundColor = prevColor; 
        }

        ConsoleColor GetTileColor(TileType type)
        {
            switch (type)
            {
                case TileType.Empty:
                    return ConsoleColor.Green;
                case TileType.Wall:
                    return ConsoleColor.Red;
                default:
                    return ConsoleColor.Green;
            }
        }
    }
}</code></pre>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;">다른 소스코드 영역은 출력을 담당하는 파트이니, <span style="background-color: #333333; color: #ffffff;">GenerateByBinaryTree 함수</span>를 중점으로 정리 하도록 하겠다. 다음은 초기 맵을 설정하는 코드이다. <b>붉은색 부분은 enum TileType 에 정의된 Wall 로, 이동 불가능한 지역</b>을 나타내며, <b>초록색 부분은 enum TileType 에 정의된 Empty 로, 이동 가능한 지역</b>을 나타낸다.</span></p>
<pre id="code_1629636789792" class="cs" data-ke-language="cs" data-ke-type="codeblock"><code>            // 초기 맵 설정
            for (int y = 0; y &lt; _size; y++)
            {
                for (int x = 0; x &lt; _size; x++)
                {
                    if (x % 2 == 0 || y % 2 == 0)
                        _tile[y, x] = TileType.Wall;
                    else
                        _tile[y, x] = TileType.Empty;
                }
            }</code></pre>
<p><figure class="imageblock alignLeft" data-origin-width="406" data-origin-height="406" data-ke-mobilestyle="widthOrigin">
    <span data-lightbox="lightbox">
        <img src="./img/img_2.png" data-origin-width="406" data-origin-height="406" data-ke-mobilestyle="widthOrigin" />
    </span>
    <figcaption></figcaption>
</figure></p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;">이동 불가능 지역 (Wall) 은 건너 뛰고 (continue) , 이동 가능한 지역 (Empty) 을 기준으로 <b>Random 클래스를 이용해 1/2 확률로 오른쪽 혹은 아래쪽으로 길을 뚫어 나간다.</b></span></p>
<pre id="code_1629636896651" class="cs" data-ke-language="cs" data-ke-type="codeblock"><code>            // Random 길뚫기
            Random rand = new Random();
            for (int y = 0; y &lt; _size; y++)
            {
                for (int x = 0; x &lt; _size; x++)
                {
                    if (x % 2 == 0 || y % 2 == 0)
                        continue;

                    if (rand.Next(0, 2) == 0)
                    {
                        _tile[y, x + 1] = TileType.Empty;
                    }
                    else
                    {
                        _tile[y + 1, x] = TileType.Empty;
                    }
                }
            }</code></pre>
<p><figure class="imageblock alignLeft" data-origin-width="405" data-origin-height="404" data-ke-mobilestyle="widthOrigin">
    <span data-lightbox="lightbox">
        <img src="./img/img_3.png" data-origin-width="405" data-origin-height="404" data-ke-mobilestyle="widthOrigin" />
    </span>
    <figcaption></figcaption>
</figure></p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;">하지만 약간 문제가 존재한다. <b>겉 테두리 부분의 일부가 이동 가능 지역으로 바뀌고 만다.&nbsp;</b></span></p>
<p><figure class="imageblock alignLeft" data-origin-width="408" data-origin-height="407" data-ke-mobilestyle="widthOrigin">
    <span data-lightbox="lightbox">
        <img src="./img/img_4.png" data-origin-width="408" data-origin-height="407" data-ke-mobilestyle="widthOrigin" />
    </span>
    <figcaption></figcaption>
</figure></p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;">따라서 다음 소스코드를 추가해 약간 보완해 주면 겉 테두리가 모두 이동 불가능 지역으로 설정된다!</span></p>
<pre id="code_1629637210128" class="cs" data-ke-language="cs" data-ke-type="codeblock"><code>                    // 보완 //
                    if (y == _size - 2)
                    {
                        _tile[y, x + 1] = TileType.Empty;
                        continue;
                    }

                    if (x == _size - 2)
                    {
                        _tile[y + 1, x] = TileType.Empty;
                        continue;
                    }
                    // 보완 //</code></pre>
<p><figure class="imageblock alignLeft" data-origin-width="604" data-origin-height="609" data-ke-mobilestyle="widthOrigin">
    <span data-lightbox="lightbox">
        <img src="./img/img_5.png" data-origin-width="604" data-origin-height="609" data-ke-mobilestyle="widthOrigin" />
    </span>
    <figcaption></figcaption>
</figure></p>
<hr contenteditable="false" data-ke-type="horizontalRule" data-ke-style="style5" />
<h2 data-ke-size="size26"><span style="font-family: 'Noto Serif KR'; color: #000000;">#참고</span></h2>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;">다음 사이트를 참고하면, Binary Tree Maze Algorithm 을 이용해 미로를 만드는 과정을 눈으로 확인할 수 있다. 또 다른 소스코드의 데모 버전도 확인 가능하니 참고하면 좋을것 같다. :)</span></p>
<p data-ke-size="size16"><a href="http://www.jamisbuck.org/mazes/" target="_blank" rel="noopener">http://www.jamisbuck.org/mazes/</a></p>
<figure id="og_1629637374686" contenteditable="false" data-ke-type="opengraph" data-ke-align="alignCenter" data-og-type="website" data-og-title="Maze Algorithms" data-og-description="Maze Algorithms If you're interested in maze algorithms, I've written a book about the subject: &quot;Mazes for Programmers&quot;. Check it out! The source code for these demos is freely available at http://github.com/jamis/csmazes. Recursive Backtracking (Parallel " data-og-host="www.jamisbuck.org" data-og-source-url="http://www.jamisbuck.org/mazes/" data-og-url="http://www.jamisbuck.org/mazes/" data-og-image=""><a href="http://www.jamisbuck.org/mazes/" target="_blank" rel="noopener" data-source-url="http://www.jamisbuck.org/mazes/">
<div class="og-image" style="background-image: url();">&nbsp;</div>
<div class="og-text">
<p class="og-title" data-ke-size="size16">Maze Algorithms</p>
<p class="og-desc" data-ke-size="size16">Maze Algorithms If you're interested in maze algorithms, I've written a book about the subject: "Mazes for Programmers". Check it out! The source code for these demos is freely available at http://github.com/jamis/csmazes. Recursive Backtracking (Parallel</p>
<p class="og-host" data-ke-size="size16">www.jamisbuck.org</p>
</div>
</a></figure>
<hr contenteditable="false" data-ke-type="horizontalRule" data-ke-style="style5" />
                        </div>
                        <br/>
                        <div class="tags">
                            #게임알고리즘 #미로생성알고리즘 #BinaryTreeMazeAlgorithm 
                        </div>
                    </div>
                </div>
            </div>
        </main>
    </div>
</div>
</body>
</html>
