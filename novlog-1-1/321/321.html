
<meta charset="utf-8">
<html lang="ko">
<head>
    <link rel="stylesheet" type="text/css" href="./../style.css" />
    <title>[BOJ] 11723 집합 JAVA & C++ 문제풀이 (feat. unordered_set & hashSet)</title>
</head>
<body id="tt-body-page" class="">
<div id="wrap" class="wrap-right">
    <div id="container">
        <main class="main ">
            <div class="area-main">
                <div class="area-view">
                    <div class="article-header">
                        <div class="inner-article-header">
                            <div class="box-meta">
                                <h2 class="title-article">[BOJ] 11723 집합 JAVA & C++ 문제풀이 (feat. unordered_set & hashSet)</h2>
                                <div class="box-info">
                                    <p class="category">Problem Solving/BOJ</p>
                                    <p class="date">2024-09-03 12:14:41</p>
                                </div>
                            </div>
                        </div>
                    </div>
                    <hr>
                    <div class="article-view">
                        <div class="contents_style">
                            <p style="text-align: center;" data-ke-size="size16"><a href="https://www.acmicpc.net/problem/11723" target="_blank" rel="noopener&nbsp;noreferrer">https://www.acmicpc.net/problem/11723</a></p>
<p style="text-align: center;" data-ke-size="size16">&nbsp;</p>
<h2 style="text-align: center;" data-ke-size="size26"><b><span style="font-family: 'Nanum Gothic'; color: #000000;">#문제접근</span></b></h2>
<p style="text-align: center;" data-ke-size="size16"><span style="background-color: #ffffff; color: #000000; text-align: start; font-family: 'Nanum Gothic';">문제를 제출한 뒤 알고리즘 분류를 보니 "비트 마스킹" 알고리즘을 사용해야 하는 문제였던 것 같다.</span><br /><span style="background-color: #ffffff; color: #000000; text-align: start; font-family: 'Nanum Gothic';">시간제한이 1.5초인데 반해 연산의 수는 300만 개로 매우 많다.</span><br /><span style="background-color: #ffffff; color: #000000; text-align: start; font-family: 'Nanum Gothic';">하지만 아직 비트 마스킹 알고리즘에 대해 공부하지 않았기에 set 자료구조를 사용해 문제를 풀이했다.</span><br /><span style="background-color: #ffffff; color: #000000; text-align: start; font-family: 'Nanum Gothic';">set 자료구조를 사용해 문제를 풀이하기 위해선 가능한 모든 시간 최적화 방안을 도입해야만 했다.</span></p>
<p style="text-align: center;" data-ke-size="size16">&nbsp;</p>
<p><figure class="imageblock alignCenter" data-origin-width="1652" data-origin-height="368" data-is-animation="false" style="width: 61.5043%; margin-right: 10px;" data-widthpercent="62.23">
    <span data-lightbox="lightbox">
        <img src="./img/img_1.png" data-origin-width="1652" data-origin-height="368" data-is-animation="false" style="width: 61.5043%; margin-right: 10px;" data-widthpercent="62.23" />
    </span>
    <figcaption></figcaption>
</figure><figure class="imageblock alignCenter" data-origin-width="1248" data-origin-height="458" data-is-animation="false" width="626" height="230" style="width: 37.3329%;" data-widthpercent="37.77">
    <span data-lightbox="lightbox">
        <img src="./img/img_2.png" data-origin-width="1248" data-origin-height="458" data-is-animation="false" width="626" height="230" style="width: 37.3329%;" data-widthpercent="37.77" />
    </span>
    <figcaption></figcaption>
</figure></p>
<p data-ke-size="size16">&nbsp;</p>
<p style="text-align: center;" data-ke-size="size16">&nbsp;</p>
<p style="text-align: center;" data-ke-size="size16"><span style="background-color: #ffffff; color: #000000; text-align: start; font-family: 'Nanum Gothic';">set 자료구조 중에 <span style="background-color: #333333; color: #dddddd;">hash table로 구현된 set</span> 을 선택하였다.</span><br /><span style="background-color: #ffffff; color: #000000; text-align: start; font-family: 'Nanum Gothic';">hash table 은 삽입, 삭제 연산이 O(1) 만에 이루어지기에 다른 set 자료구조에 비해서 효율적이다.</span><br /><span style="background-color: #ffffff; color: #000000; text-align: start; font-family: 'Nanum Gothic';">물론 문제 출제자가 의도적으로 최악의 해시 충돌을 강제하는 테스트케이스를 다량으로 추가할 시 시간 복잡도가 O(N)이 되기에,</span><br /><span style="background-color: #ffffff; color: #000000; text-align: start; font-family: 'Nanum Gothic';">테스트케이스를 통과하지 못할 가능성도 있었다.</span><br /><br /><span style="background-color: #f6e199; color: #000000; text-align: start; font-family: 'Nanum Gothic';">* JAVA 언어의 경우 HashSet 구현체를, C++ 언어의 경우 unordered_map STL 을 사용하면 된다.</span></p>
<p style="text-align: center;" data-ke-size="size16">&nbsp;</p>
<p style="text-align: center;" data-ke-size="size16">[관련 포스팅]</p>
<p style="text-align: center;" data-ke-size="size16"><a href="https://novlog.tistory.com/entry/JAVA-HashSet-vs-LinkedHashSet-vs-TreeSet" target="_blank" rel="noopener">Java HashSet vs LinkedHashSet vs TreeSet</a></p>
<p style="text-align: center;" data-ke-size="size16"><a href="https://novlog.tistory.com/entry/DataStructure-Hash-%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-%EA%B0%9C%EB%85%90-%EC%A0%95%EB%A6%AC" target="_blank" rel="noopener">about HashTable</a></p>
<p style="text-align: center;" data-ke-size="size16">&nbsp;</p>
<hr contenteditable="false" data-ke-type="horizontalRule" data-ke-style="style5" />
<h2 style="text-align: center;" data-ke-size="size26"><b><span style="font-family: 'Nanum Gothic'; color: #000000;">#Java</span></b></h2>
<p style="text-align: center;" data-ke-size="size16">&nbsp;</p>
<p style="text-align: center;" data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;">1. 입력데이터가 300만개로 굉장히 많기에 Scanner 객체를 사용하면 시간초과가 발생한다.</span></p>
<p style="text-align: center;" data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;"><span style="background-color: #333333; color: #dddddd;">BufferedReader</span>를 사용해 입출력 시간을 최소화하자.</span></p>
<pre id="code_1725332632613" class="java" data-ke-language="java" data-ke-type="codeblock"><code>BufferedReader br = new BufferedReader(new InputStreamReader(System.in));</code></pre>
<p style="text-align: center;" data-ke-size="size16">&nbsp;</p>
<p style="text-align: center;" data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;">2. check command 처리 부분에서 System.out.println으로 바로 결과를 출력해 주면 시간초과가 발생한다.</span></p>
<p style="text-align: center;" data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;"><span style="background-color: #333333; color: #dddddd;">StringBuilder 객체</span>를 사용하여 출력 결과를 버퍼에 저장해 둔 뒤 한 번에 출력해야 한다.</span></p>
<pre id="code_1725332715270" class="java" data-ke-language="java" data-ke-type="codeblock"><code>StringBuilder sb = new StringBuilder();
for (int i = 0; i &lt; m; i++) {

			...

            else if (command.equals("check")) {
                Integer value = Integer.parseInt(commands[1]);
                if (set.contains(value)) sb.append("1" + '\n');
                else sb.append("0" + '\n');
            }
            
            ...
        }

        System.out.println(sb.toString());
}</code></pre>
<p style="text-align: center;" data-ke-size="size16">&nbsp;</p>
<h3 style="text-align: center;" data-ke-size="size23"><span style="font-family: 'Nanum Gothic'; color: #000000;">#전체 코드</span></h3>
<pre id="code_1725332604732" class="java" data-ke-language="java" data-ke-type="codeblock"><code>package september;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.Arrays;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

public class BOJ11723 {
    public static void main(String[] args) throws IOException {
        Set&lt;Integer&gt; set = new HashSet&lt;&gt;();
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringBuilder sb = new StringBuilder();
        int m = Integer.parseInt(br.readLine());
        for (int i = 0; i &lt; m; i++) {

            String[] commands = br.readLine().split(" ");
            String command = commands[0];

            if (command.equals("add")) {
                Integer value = Integer.parseInt(commands[1]);
                set.add(value);
            }

            else if (command.equals("check")) {
                Integer value = Integer.parseInt(commands[1]);
                if (set.contains(value)) sb.append("1" + '\n');
                else sb.append("0" + '\n');
            }

            else if (command.equals("remove")) {
                Integer value = Integer.parseInt(commands[1]);
                if (set.contains(value)) {
                    set.remove(value);
                }
            }

            else if (command.equals("toggle")) {
                Integer value = Integer.parseInt(commands[1]);
                if (set.contains(value)) {
                    set.remove(value);
                }
                else {
                    set.add(value);
                }
            }

            else if (command.equals("all")) {
                set.clear();
                for (int j = 1; j &lt;= 20; j++) {
                    set.add(j);
                }
            }

            else if (command.equals("empty")) {
                set = new HashSet&lt;Integer&gt;();
            }
        }

        System.out.println(sb.toString());

        br.close();
    }
}</code></pre>
<hr contenteditable="false" data-ke-type="horizontalRule" data-ke-style="style5" />
<h2 style="text-align: center;" data-ke-size="size26"><b><span style="font-family: 'Nanum Gothic'; color: #000000;">#C++</span></b></h2>
<p style="text-align: center;" data-ke-size="size16">&nbsp;</p>
<p style="text-align: center;" data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;">1. cin, cout 버퍼를 묶어주어 입출력 시 발생하는 시간을 최소화한다.</span></p>
<pre id="code_1725332858026" class="java" data-ke-language="java" data-ke-type="codeblock"><code>    ios::sync_with_stdio(false);
    cin.tie(NULL);
    cout.tie(NULL);</code></pre>
<p data-ke-size="size16">&nbsp;</p>
<p style="text-align: center;" data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;">2. "all", "empty" command를 처리하는 과정에서 clear 메서드를 사용했더니 시간초과가 발생했다.</span></p>
<p style="text-align: center;" data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;">c++ unordered_set의 clear method에 관한 내용을 stackoverflow에서 찾아보니 <span style="background-color: #f6e199;">clear 연산은 처음부터 끝까지 모든원소를 순회하기에 O(N)만큼의 시간 복잡도가 소요</span>된다고 한다.</span></p>
<p style="text-align: center;" data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;">따라서 clear 메서드를 사용하지 않고 직접 값을 대입해 주었다.</span></p>
<p><figure class="imageblock alignCenter" width="762" height="203" >
    <span data-lightbox="lightbox">
        <img src="./img/img.png" width="762" height="203"  />
    </span>
    <figcaption></figcaption>
</figure></p>
<pre id="code_1725332882165" class="java" data-ke-language="java" data-ke-type="codeblock"><code>        else if (command == "all") {
            // set.clear();
            set = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20};
        }
        else if (command == "empty") {
            set = {};
        }</code></pre>
<p style="text-align: center;" data-ke-size="size16">&nbsp;</p>
<h3 style="text-align: center;" data-ke-size="size23"><span style="font-family: 'Nanum Gothic'; color: #000000;">#전체 코드</span></h3>
<pre id="code_1725333049731" class="cpp" data-ke-language="cpp" data-ke-type="codeblock"><code>#include &lt;unordered_map&gt;
#include &lt;unordered_set&gt;
using namespace std;
#include &lt;iostream&gt;

int main() {

    ios::sync_with_stdio(false);
    cin.tie(NULL);
    cout.tie(NULL);

    int m = 0;
    cin &gt;&gt; m;
    cin.ignore(); // cin buffer clear
    unordered_set&lt;int&gt; set;

    for (int i = 0; i &lt; m; i++) {

        // getline - 공백 기준 입력
        string commands = "";
        getline(cin, commands);

        // String - Parsing
        int delimiter = commands.find(" ");
        string command = commands.substr(0, delimiter);
        string oper = commands.substr(delimiter + 1);


        if (command == "add") {
            set.insert(stoi(oper));
        }
        else if (command == "remove") {
            set.erase(stoi(oper));
        }
        else if (command == "check") {
            // set에 원소가 존재하는 경우
            // end() iterator를 반환하지 않는 경우
            if (set.find(stoi(oper)) != set.end()) {
                cout &lt;&lt; "1" &lt;&lt; '\n';
            }
            // set에 원소가 존재하지 않는 경우
            else {
                cout &lt;&lt; "0" &lt;&lt; '\n';
            }
        }
        else if (command == "toggle") {
            // set에 원소가 존재하는 경우
            if (set.find(stoi(oper)) != set.end()) {
                set.erase(stoi(oper));
            }
            else {
                set.insert(stoi(oper));
            }
        }
        else if (command == "all") {
            // set.clear();
            set = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20};
        }
        else if (command == "empty") {
            set = {};
        }
    }

    return 0;
}</code></pre>
<hr contenteditable="false" data-ke-type="horizontalRule" data-ke-style="style5" />
<p style="text-align: center;" data-ke-size="size16">&nbsp;</p>
                        </div>
                        <br/>
                        <div class="tags">
                            
                        </div>
                    </div>
                </div>
            </div>
        </main>
    </div>
</div>
</body>
</html>
