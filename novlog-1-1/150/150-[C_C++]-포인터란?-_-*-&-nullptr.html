
<meta charset="utf-8">
<html lang="ko">
<head>
    <link rel="stylesheet" type="text/css" href="./../style.css" />
    <title>[C/C++] 포인터란? _ * & nullptr</title>
</head>
<body id="tt-body-page" class="">
<div id="wrap" class="wrap-right">
    <div id="container">
        <main class="main ">
            <div class="area-main">
                <div class="area-view">
                    <div class="article-header">
                        <div class="inner-article-header">
                            <div class="box-meta">
                                <h2 class="title-article">[C/C++] 포인터란? _ * & nullptr</h2>
                                <div class="box-info">
                                    <p class="category">? Archive/C&C++</p>
                                    <p class="date">2022-01-27 12:13:36</p>
                                </div>
                            </div>
                        </div>
                    </div>
                    <hr>
                    <div class="article-view">
                        <div class="contents_style">
                            <p data-ke-size="size16"><span style="background-color: #f6e199;"><b><span style="font-family: 'Nanum Gothic'; color: #000000;">* 개인적인 공부 내용을 기록하는 용도로 작성한 글 이기에 잘못된 내용을 포함하고 있을 수 있습니다.</span></b></span></p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16"><b><span style="font-family: 'Nanum Gothic'; color: #000000;">#1 메모리 저장 방식</span></b></p>
<p data-ke-size="size16"><b><span style="font-family: 'Nanum Gothic'; color: #000000;">#2 포인터(Pointer) 연산자 * &amp;</span></b></p>
<p data-ke-size="size16"><b><span style="font-family: 'Nanum Gothic'; color: #000000;">#3 포인터가 필요한 이유</span></b></p>
<p data-ke-size="size16"><b><span style="font-family: 'Nanum Gothic'; color: #000000;">#4 포인터 문법</span></b></p>
<p data-ke-size="size16"><b><span style="font-family: 'Nanum Gothic'; color: #000000;">- 포인터 변수 선언</span></b></p>
<p data-ke-size="size16"><b><span style="font-family: 'Nanum Gothic'; color: #000000;">- 널 포인터</span></b></p>
<hr contenteditable="false" data-ke-type="horizontalRule" data-ke-style="style5" />
<p data-ke-size="size18"><b><span style="font-family: 'Nanum Gothic'; background-color: #333333; color: #ffffff;">#1 메모리 저장 방식</span></b></p>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;">포인터를 공부하기에 앞서 우선 프로그래머가 변수를 선언할 시 데이터가 메모리에 어떤 방식으로 저장되는지에 대해 알아 보도록 합시다.</span></p>
<pre id="code_1643249114678" class="c++ arduino" data-ke-language="c++" data-ke-type="codeblock"><code>int val = 10;</code></pre>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;"><b>"val 이라는 이름의 int 타입 변수를 선언하고 10을 할당했다."</b> 라는 것은 컴퓨터가 어딘가의 메모리 공간에 4byte 를 할당하고 그 메모리 공간의 이름은 프로그래머가 사용하기 쉽도록 val이라는 명칭을 붙여준 것입니다.</span></p>
<pre id="code_1643249385267" class="c++ arduino" data-ke-language="c++" data-ke-type="codeblock"><code>cout &lt;&lt; (uintptr_t)&amp;val &lt;&lt; endl;</code></pre>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;">따라서 &amp;연산자 (&amp;연산자는 메모리의 주소를 가져와 주는 역할을 수행합니다. 뒤에서 자세하게 다룰 예정입니다.) 를 이용해 val 의 주소를 출력해보면 다음과 같이 val의 메모리가 할당되어 있는 메모리 주소가 출력됩니다. (단, 메모리 주소는 휘발성이기에 프로그램을 껐다 키면 바뀌어 있으며 운영체제 혹은 컴파일러 마다 출력 방식이 다릅니다.)</span></p>
<pre id="code_1643249453906" class="c++ arduino" data-ke-language="c++" data-ke-type="codeblock"><code>140726076202556</code></pre>
<p><figure class="imageblock alignCenter" >
    <span data-lightbox="lightbox">
        <img src="./img/img.png"  />
    </span>
    <figcaption>메모리 공간</figcaption>
</figure></p>
<hr contenteditable="false" data-ke-type="horizontalRule" data-ke-style="style5" />
<p data-ke-size="size18"><b><span style="font-family: 'Nanum Gothic'; color: #ffffff; background-color: #333333;">#2 포인터(Pointer) 연산자 * &amp;</span></b></p>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;">포인터 연산자를 이용하면 <b>메모리의 주소를 가져올 수도있고, 메모리 공간에 직접 접근</b>할 수 도 있습니다.</span></p>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;">포인터 연산자의 종류는 <span style="background-color: #f6e199;">&amp;(address-of operator)</span> 와 <span style="background-color: #f6e199;">*(de-referencing-operator)</span>가 있습니다.</span></p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;"><b>&amp;(address-of operator)연산자</b>를 이용하면 메모리 공간의 주소를 가져올 수 있습니다. 다음은 int 타입 변수 x를 선언하고 x의 메모리 주소를 출력한 예제 코드입니다.</span></p>
<pre id="code_1643250248077" class="c++ arduino" data-ke-language="c++" data-ke-type="codeblock"><code>int main(int argc, char* argv[]){
	int x = 1;
	cout &lt;&lt; &amp;x &lt;&lt; endl;
}</code></pre>
<pre id="code_1643250271839" class="c++ arduino" data-ke-language="c++" data-ke-type="codeblock"><code>0x7ffe3b8350cc</code></pre>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;"><b>*(de-referencing-operator)연산자</b>를 이용하면 메모리 공간의 값에 직접 접근할 수 있습니다.</span></p>
<pre id="code_1643251082196" class="c++ arduino" data-ke-language="c++" data-ke-type="codeblock"><code>int main(int argc, char* argv[]){
	int x = 1;
	cout &lt;&lt; *(&amp;x) &lt;&lt; endl;
}</code></pre>
<pre id="code_1643251088641" class="c++ arduino" data-ke-language="c++" data-ke-type="codeblock"><code>1</code></pre>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;">위 코드는 변수 x의 메모리 공간에 *연산자를 이용해 직접 접근해 메모리 공간에 저장된 값을 출력한 예제입니다.&nbsp;</span></p>
<p><figure class="imageblock alignLeft" >
    <span data-lightbox="lightbox">
        <img src="./img/img_1.png"  />
    </span>
    <figcaption></figcaption>
</figure></p>
<p data-ke-size="size16">&nbsp;</p>
<hr contenteditable="false" data-ke-type="horizontalRule" data-ke-style="style5" />
<p data-ke-size="size18"><b><span style="font-family: 'Nanum Gothic'; color: #ffffff; background-color: #333333;">#3 포인터가 필요한 이유</span></b></p>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;">포인터라는 문법이 왜 필요한지 한 가지 상황을 예시로 이해해 보도록 하겠습니다. </span><span style="font-family: 'Nanum Gothic'; color: #000000;">다음은 두 변수를 받아 s변수에 저장한 후 반환하는 sum 이라는 함수입니다.</span></p>
<pre id="code_1643250944737" class="c++ arduino" data-ke-language="c++" data-ke-type="codeblock"><code>#include &lt;iostream&gt;
using namespace std;

void sum (int x, int y, int s) {
	s = x + y;
}

int main(int argc, char* argv[]){
	int x = 1;
	int y = 2;
	int s = 0;
	sum(x, y, s);
	cout &lt;&lt; "sum func() - " &lt;&lt; s &lt;&lt; endl;
	return 0;
}</code></pre>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;">하지만 위의 코드를 실행시켜 보면, 기대한 바와 달리 x, y 값의 합인 3이 아닌 0이 출력됨을 확인할 수 있습니다.</span></p>
<pre id="code_1643251762266" class="c++ arduino" data-ke-language="c++" data-ke-type="codeblock"><code>0</code></pre>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;">그렇다면 왜 위와 같은 상황이 발생하는 것일까요? 그 이유는 <b>sum 함수 매개변수 s와 main 함수부의 s는 전혀 다른 변수라서 sum 함수에서 계산한 값이 서로 전혀 다른 메모리 공간에 저장되어 버린 것입니다.</b></span></p>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;">정말 그런지 &amp;연산자를 이용해 주소값을 출력해 보도록 하겠습니다.</span></p>
<pre id="code_1643252168659" class="c++ arduino" data-ke-language="c++" data-ke-type="codeblock"><code>#include &lt;iostream&gt;
using namespace std;

void sum (int x, int y, int s) {
	s = x + y;
	cout &lt;&lt; "sum() s address - " &lt;&lt; (uintptr_t)&amp;s &lt;&lt; endl;
}

int main(int argc, char* argv[]){
	int x = 1;
	int y = 2;
	int s = 0;
	cout &lt;&lt; "main() s address - " &lt;&lt; (uintptr_t)&amp;s &lt;&lt; endl;
	return 0;
}</code></pre>
<pre id="code_1643252181913" class="c++ arduino" data-ke-language="c++" data-ke-type="codeblock"><code>main() s address - 140721819028780
sum() s address - 140721819028724</code></pre>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;">따라서 main 함수의 s값을 직접 변경하고 싶다면 포인터를 이용해 메모리의 주소 값을 직접 지정해 주어야 합니다. 아래 코드를 실행시켜보면, 실제로 main 함수의 s값이 변경되어 있음을 확인할 수 있습니다.</span></p>
<pre id="code_1643252323799" class="c++ arduino" data-ke-language="c++" data-ke-type="codeblock"><code>#include &lt;iostream&gt;
using namespace std;

void ptSum (int x, int y, int *s) {
	*s = x + y;
}

int main(int argc, char* argv[]){
	int x = 1;
	int y = 2;
	int s = 0;
	ptSum(x, y, &amp;s);
	cout &lt;&lt; "ptSum func() - " &lt;&lt; s &lt;&lt; endl;
	return 0;
}</code></pre>
<pre id="code_1643252373937" class="html xml" data-ke-language="html" data-ke-type="codeblock"><code>ptSum func() - 3</code></pre>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;">위의 상황은 포인터가 필요한 단편적인 하나의 예시일 뿐이고, 실제로 포인터는 다양한 상황에서 활용됩니다.</span></p>
<hr contenteditable="false" data-ke-type="horizontalRule" data-ke-style="style5" />
<p data-ke-size="size18"><b><span style="font-family: 'Nanum Gothic'; color: #ffffff; background-color: #333333;">#4 포인터 문법</span></b></p>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000; background-color: #f6e199;">- 포인터 변수 선언</span></p>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;"><b>포인터란 메모리의 주소를 저장할 수 있는 "자료형"</b>&nbsp;입니다. 포인터도 int char double .. 등과 같이 하나의 타입입니다. 포인터 변수 선언시에는, 데이터 타입을 작성하고 그 뒤에 *를 붙여 주면 됩니다.&nbsp;</span></p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16"><span style="color: #000000; font-family: 'Nanum Gothic';">int* ptr... int type 포인터 변수</span></p>
<p data-ke-size="size16"><span style="color: #000000; font-family: 'Nanum Gothic';">char* ptr... char type 포인터 변수</span></p>
<p data-ke-size="size16"><span style="color: #000000; font-family: 'Nanum Gothic';">double* ptr... double type 포인터 변수</span></p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16"><span style="color: #000000; font-family: 'Nanum Gothic';">여기서 *의 위치는 어디에 붙여도 상관 없습니다.<b> int* ptr = int *ptr = int * ptr</b></span></p>
<pre id="code_1643252758553" class="c++ arduino" data-ke-language="c++" data-ke-type="codeblock"><code>int val = 10;
int *ptr = &amp;val; // int type 포인터 변수</code></pre>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000; background-color: #f6e199;">- NULL 포인터</span></p>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;">포인터를 사용 시 주의해야 할 점이 있습니다. 바로 <b>포인터에 값이 담겨져 있지 않은데, de-referencing(*)을 하는 상황</b>입니다.</span></p>
<pre id="code_1643252844784" class="c++ arduino" data-ke-language="c++" data-ke-type="codeblock"><code>int *ptr;
*ptr = 10;</code></pre>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;">이는 매우 치명적인 상황을 발생시킬 수 있습니다. ptr 값이 어떤 메모리 변수를 가리키는 지 알 수 없기 때문입니다.</span></p>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;">따라서 포인터에 주소값을 대입하지 않을 경우 null 포인터를 사용해 초기화 해야 합니다.</span></p>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;"><b>NULL 혹은 nullptr 키워드</b>를 이용해 초기화할 수 있는데, <b>NULL 은 주로 C</b>에서 <b>nullptr은 주로 modern C++</b> 에서 사용하는 키워드입니다.</span></p>
<pre id="code_1643253010567" class="c++ arduino" data-ke-language="c++" data-ke-type="codeblock"><code>int *ptr; // 위험!
int *ptr = NULL; // C Style
int *ptr = nullptr // modern C++ Style</code></pre>
<hr contenteditable="false" data-ke-type="horizontalRule" data-ke-style="style5" />
<p data-ke-size="size16">&nbsp;</p>
                        </div>
                        <br/>
                        <div class="tags">
                            #포인터 #nullptr #&연산자 #NULL포인터 #*연산자 #포인터주의점 #포인터사용법 #포인터가필요한이유 #포인터문법 
                        </div>
                    </div>
                </div>
            </div>
        </main>
    </div>
</div>
</body>
</html>
