
<meta charset="utf-8">
<html lang="ko">
<head>
    <link rel="stylesheet" type="text/css" href="./../style.css" />
    <title>[LeetCode] 169. Majority Element 문제 풀이 C++ (feat. 과반수 투표 알고리즘)</title>
</head>
<body id="tt-body-page" class="">
<div id="wrap" class="wrap-right">
    <div id="container">
        <main class="main ">
            <div class="area-main">
                <div class="area-view">
                    <div class="article-header">
                        <div class="inner-article-header">
                            <div class="box-meta">
                                <h2 class="title-article">[LeetCode] 169. Majority Element 문제 풀이 C++ (feat. 과반수 투표 알고리즘)</h2>
                                <div class="box-info">
                                    <p class="category">? Archive/ProblemSolving</p>
                                    <p class="date">2022-09-03 14:22:45</p>
                                </div>
                            </div>
                        </div>
                    </div>
                    <hr>
                    <div class="article-view">
                        <div class="contents_style">
                            <h2 data-ke-size="size26"><b><span style="font-family: 'Nanum Gothic'; color: #000000;">#INFO</span></b></h2>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;">난이도 : <span style="background-color: #9feec3;">Easy</span></span></p>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic';"><span style="color: #000000;">출처 :</span> <a href="https://leetcode.com/problems/majority-element/" target="_blank" rel="noopener">https://leetcode.com/problems/majority-element/</a></span></p>
<figure id="og_1662179495910" contenteditable="false" data-ke-type="opengraph" data-ke-align="alignCenter" data-og-type="website" data-og-title="Majority Element - LeetCode" data-og-description="Level up your coding skills and quickly land a job. This is the best place to expand your knowledge and get prepared for your next interview." data-og-host="leetcode.com" data-og-source-url="https://leetcode.com/problems/majority-element/" data-og-url="https://leetcode.com/problems/majority-element/" data-og-image="https://scrap.kakaocdn.net/dn/dzoEwf/hyPFWeUEMN/pH7zWn60ZFmTTAPaN1YrMK/img.png?width=500&amp;height=260&amp;face=0_0_500_260"><a href="https://leetcode.com/problems/majority-element/" target="_blank" rel="noopener" data-source-url="https://leetcode.com/problems/majority-element/">
<div class="og-image" style="background-image: url('https://scrap.kakaocdn.net/dn/dzoEwf/hyPFWeUEMN/pH7zWn60ZFmTTAPaN1YrMK/img.png?width=500&amp;height=260&amp;face=0_0_500_260');">&nbsp;</div>
<div class="og-text">
<p class="og-title" data-ke-size="size16">Majority Element - LeetCode</p>
<p class="og-desc" data-ke-size="size16">Level up your coding skills and quickly land a job. This is the best place to expand your knowledge and get prepared for your next interview.</p>
<p class="og-host" data-ke-size="size16">leetcode.com</p>
</div>
</a></figure>
<p><figure class="imageblock alignLeft" >
    <span data-lightbox="lightbox">
        <img src="./img/img.png"  />
    </span>
    <figcaption></figcaption>
</figure></p>
<hr contenteditable="false" data-ke-type="horizontalRule" data-ke-style="style5" />
<h2 data-ke-size="size26"><b><span style="font-family: 'Nanum Gothic'; color: #000000;">#SOLVE</span></b></h2>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;">다양한 방식으로 접근할 수 있는 문제입니다.&nbsp;</span></p>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;">비효율적인 코드로도 풀이할 수 있지만 Follow-up 조건인 <span style="background-color: #dddddd;">Time Complexity - Linear Time &amp; Space Complexity - O(1)</span> 을 지켜서 문제를 풀이하고자 할 경우엔 상당히 애를 먹을 수 있습니다.</span></p>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;">(단, Follow-up 조건을 지키지 않아도 제출이 되기는 합니다.)</span></p>
<p data-ke-size="size16">&nbsp;</p>
<h3 data-ke-size="size23"><span style="color: #1a5490;"><b><span style="font-family: 'Nanum Gothic';">1. Brute Force&nbsp;</span></b></span></h3>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #dddddd; background-color: #333333;">Time Complexity - O(N&sup2;)</span></p>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;">첫 번째 방식은 가장 직관적인 Brute Force (완전 탐색) 알고리즘을 이용한 풀이입니다.</span></p>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;">그냥 <b>이중 For 문을 사용해 배열에 존재하는 모든 원소를 차례로 탐색</b>한 뒤&nbsp; 배열의 크기 (n) / 2 를 초과하는 원소가 나온다면 그대로 출력하면 됩니다.</span></p>
<pre id="code_1662179919057" class="cpp" data-ke-language="cpp" data-ke-type="codeblock"><code>class Solution {
public:
    int majorityElement(vector&lt;int&gt;&amp; nums) {
        int majority = nums.size() / 2;
        for(const int&amp; i : nums){
            int count = 0;
            for(const int&amp; j : nums){
                if(j == i) count++;
            }
            if(count &gt; majority){ 
                return i;
            }
        }
        return 0;
    }
};</code></pre>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;">하지만 for을 2중으로 겹치다 보니 시간 복잡도가 O(N&sup2;)이 되어 Time Limit Exceeded가 출력 되었습니다.</span></p>
<p><figure class="imageblock alignLeft" >
    <span data-lightbox="lightbox">
        <img src="./img/img_1.png"  />
    </span>
    <figcaption></figcaption>
</figure></p>
<p data-ke-size="size16">&nbsp;</p>
<h3 data-ke-size="size23"><span style="color: #1a5490;"><b><span style="font-family: 'Nanum Gothic';">2. Hash&nbsp;</span></b></span></h3>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #dddddd; background-color: #333333;">Time Complexity - O(N)</span></p>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #dddddd; background-color: #333333;">Space Complexity - O(N)</span></p>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;">이번에는 해시 자료구조 를 사용해 문제를 풀이해 보도록 하겠습니다.&nbsp;</span></p>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;">STL의 <b>unordered_map container</b>를 사용했습니다.</span></p>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;">(*unordered_map container의 사용법에 대해 모르시는 분들은 다음 포스팅을 참고해 주세요.)</span></p>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic';"><a href="https://novlog.tistory.com/265" target="_blank" rel="noopener">&rarr; STL map Container 사용 방법 정리 (feat map &amp; [hash_map]unordered_map &amp; multi_map)</a></span></p>
<pre id="code_1662180763515" class="cpp" data-ke-language="cpp" data-ke-type="codeblock"><code>class Solution {
public:
    int majorityElement(vector&lt;int&gt;&amp; nums) {
        unordered_map&lt;int, int&gt; major;
        for(const auto&amp; i : nums){
            if(major.end() == major.find(i)) major[i] = 1;
            else major[i]++;
        }
        for(const auto&amp; i : major){
            if(i.second &gt; nums.size() / 2) 
                return i.first;
        }
        return 0;
    }
};</code></pre>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;">unordered_map&lt;int, int&gt; type major 를 하나 선언한 뒤, nums vector를 탐색합니다.</span></p>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;">만약 major에 탐색중인 원소가 존재하지 않는다면 키값으로 새로 추가합니다.</span></p>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;">혹은 탐색중인 원소가 major에 존재한다면 major의 value를 1 증가시킵니다.</span></p>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;">마지막으로 major의 키값을 모두 탐색하여 키의 value가 nums.size() / 2 보다 큰 키를 발견하면 키값을 리턴합니다.</span></p>
<p><figure class="imageblock alignLeft" >
    <span data-lightbox="lightbox">
        <img src="./img/img_2.png"  />
    </span>
    <figcaption></figcaption>
</figure></p>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;">Hash 자료구조를 이용한 방식은 Time Complexity 는 Linear Time 즉, O(N)시간에 탐색하여 제출에 성공하긴 했지만 Space Complexity가 O(N)으로 Follow-up 제시 조건인 O(1) 을 만족하지는 못합니다.</span></p>
<p data-ke-size="size16">&nbsp;</p>
<h3 data-ke-size="size23"><span style="color: #1a5490;"><b><span style="font-family: 'Nanum Gothic';">3. Moore's Voting Algorithm 과반수 투표 알고리즘</span></b></span></h3>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #dddddd; background-color: #333333;">Time Complexity - O(N)</span></p>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #dddddd; background-color: #333333;">Space Complexity - O(1)</span></p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;">마지막은 과반수 투표 알고리즘을 이용한 풀이입니다.</span></p>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;">과반수 투표 알고리즘은 <b>배열 내에 과반수에 해당하는 원소가 존재하는 보장이 된다면 결과값으로 항상 과반수 원소를 도출</b>합니다.&nbsp;</span></p>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;"><b>단, 과반수 만큼의 원소가 등장한다는 보장이 없으면 가비지값이 도출될 수도 있습니다.</b> 하지만 이 문제는 문제에서 항상 배열 안에 과반수 이상의 원소가 등장한다는 코멘트가 달려있기에 이 알고리즘을 사용해도 괜찮습니다.</span></p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;">원리는 간단합니다.</span></p>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;">한 지역구의 투표자들이 국회의원을 뽑는다고 가정해 봅시다.</span></p>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;">투표자는 총 7명이며, 2명의 후보가 국회의원 선거에 출마했습니다.</span></p>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;">1번 후보를 선택 시에는 1이 적힌 투표용지를, 2번 후보를 선택하는 경우엔 2가 적힌 투표용지를 제출합니다.</span></p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;">여기서 2종류의 변수를 선언합니다. 변수의 용도는 다음과 같습니다.</span></p>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;"><u><b>majority</b></u> : 당선이 유력한 후보</span></p>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;"><u><b>count</b></u> : 출마자 간의 투표수 차이</span></p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16"><b><span style="font-family: 'Nanum Gothic'; color: #000000;">1번째 투표자가 2번 후보를 투표했습니다.</span></b></p>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;">2번 후보자와 1번 후보자 사이의 투표차(count)는 1이며, 현재 당선이 <b>유력한 후보(majority)는 2번 후보</b>가 되었습니다.</span></p>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;">count : 1, majority : 1번 후보</span></p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16"><b><span style="font-family: 'Nanum Gothic'; color: #000000;">2번째 투표자도 마찬가지로 2번 후보를 투표했습니다.</span></b></p>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;">count : 2 , majority : 2번 후보</span></p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16"><b><span style="font-family: 'Nanum Gothic'; color: #000000;">3번째 투표자는 1번 후보를 투표했습니다.</span></b></p>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;">count : 1 , majority : 2번 후보</span></p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16"><b><span style="font-family: 'Nanum Gothic'; color: #000000;">4번째 투표자가 1번 후보를 투표했습니다.</span></b></p>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;">count : 0, majority : 2번 후보</span></p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16"><b><span style="font-family: 'Nanum Gothic'; color: #000000;">5번째 투표자가 1번 후보를 투표했습니다.</span></b></p>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;">이제 당선이 <b>유력한 출마자(majority)가 2번 후보에서 1번 후보로 변경</b>됩니다.</span></p>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;">count : 1, majority : 1번 후보</span></p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16"><b><span style="font-family: 'Nanum Gothic'; color: #000000;">6번째 투표자가 2번 후보를 투표했습니다.</span></b></p>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;">count : 0, majority : 1번 후보</span></p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16"><b><span style="font-family: 'Nanum Gothic'; color: #000000;">7번째 투표자가 2번 후보를 투표했습니다.</span></b></p>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;"><b>majority가 2번 후보로 변경</b>됩니다.</span></p>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;">count : 1, majority : 2번 후보</span></p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;">투표자들의 투표가 종료되어 <b>2번 후보가 당선</b>됩니다.</span></p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;">위 과정을 코드로 표현하면 다음과 같습니다.</span></p>
<pre id="code_1662182260475" class="cpp" data-ke-language="cpp" data-ke-type="codeblock"><code>class Solution {
public:
    int majorityElement(vector&lt;int&gt;&amp; nums) {
        int majority, count = 0;
        for(int i = 0; i &lt; nums.size(); ++i){
            if(count != 0){
                count += (nums[i] == majority ? 1 : -1);
            }
            else{
                majority = nums[i];
                ++count;
            }
        }
        return majority;
    }
};</code></pre>
<hr contenteditable="false" data-ke-type="horizontalRule" data-ke-style="style5" />
                        </div>
                        <br/>
                        <div class="tags">
                            #C++ #알고리즘 #문제풀이 #Hash Table #Leetcode #Top 100 Liked Question 
                        </div>
                    </div>
                </div>
            </div>
        </main>
    </div>
</div>
</body>
</html>
