
<meta charset="utf-8">
<html lang="ko">
<head>
    <link rel="stylesheet" type="text/css" href="./../style.css" />
    <title>[Java] 쓰레드 생성 방법 Thread & Runnable Interface</title>
</head>
<body id="tt-body-page" class="">
<div id="wrap" class="wrap-right">
    <div id="container">
        <main class="main ">
            <div class="area-main">
                <div class="area-view">
                    <div class="article-header">
                        <div class="inner-article-header">
                            <div class="box-meta">
                                <h2 class="title-article">[Java] 쓰레드 생성 방법 Thread & Runnable Interface</h2>
                                <div class="box-info">
                                    <p class="category">Back-end/Multi Thread Programming</p>
                                    <p class="date">2024-09-12 17:10:09</p>
                                </div>
                            </div>
                        </div>
                    </div>
                    <hr>
                    <div class="article-view">
                        <div class="contents_style">
                            <p style="text-align: center;" data-ke-size="size16"><b><span style="font-family: 'Nanum Gothic'; color: #000000;">✨Goal</span></b></p>
<p style="text-align: center;" data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;">1. Thread Class를 상속받아 스레드를 생성하는 방법에 대해 숙지한다.</span></p>
<p style="text-align: center;" data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;">2. Runnable Interface를 구현하여 스레드를 생성하는 방법에 대해 숙지한다.</span></p>
<hr contenteditable="false" data-ke-type="horizontalRule" data-ke-style="style6" />
<p style="text-align: left;" data-ke-size="size16">&nbsp;</p>
<p style="text-align: left;" data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;">자바에서 스레드를 생성하는 방법은 <span style="background-color: #333333; color: #dddddd;">Thread 클래스를 상속받는 방식</span>과 <span style="background-color: #333333; color: #dddddd;">Runnable 인터페이스를 구현하는 방식</span>으로 나뉜다. </span></p>
<p style="text-align: left;" data-ke-size="size16">&nbsp;</p>
<h2 style="text-align: left;" data-ke-size="size26"><b><span style="font-family: 'Nanum Gothic'; color: #000000;">#1 extends Thread</span></b></h2>
<p style="text-align: left;" data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;"><span style="background-color: #333333; color: #dddddd;">Thread 클래스</span>를 상속받아 스레드를 생성한다.&nbsp;</span><span style="font-family: 'Nanum Gothic'; color: #000000;"></span></p>
<p style="text-align: left;" data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;"><span style="background-color: #333333; color: #dddddd;">* Thread.currentThread().getName()</span> - 현재 실행중인 스레드의 이름을 반환한다.</span></p>
<p style="text-align: left;" data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;">run() 메서드 내부에 스레드가 수행할 동작을 명시하며 외부에서 start() 메서드를 호출하면 스레드 내부의 run() 메서드가 호출된다. </span></p>
<pre id="code_1726026152231" class="java" data-ke-language="java" data-ke-type="codeblock"><code>public class MyThread extends Thread{
    @Override
    public void run() {
        System.out.println(Thread.currentThread().getName() + ": run()");
    }
}</code></pre>
<pre id="code_1726026360371" class="java" data-ke-language="java" data-ke-type="codeblock"><code>public class MyThreadMain {
    public static void main(String[] args) {

        MyThread myThread1 = new MyThread();
        MyThread myThread2 = new MyThread();
        myThread1.start(); // myThread1.run()
        myThread2.start(); // myThread2.run()
        
    }
}</code></pre>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16">스레드의 실행순서는 운영체제의 스케줄링 방식에 따라 결정되어 매 번 달라지기에 보장되지 않는다.</p>
<p data-ke-size="size16">별도의 스레드 명을 설정해 주지 않을 경우 아래 콘솔 결과와 같이 (Thread-N ...) 임의로 부여된다.</p>
<pre id="code_1726026432180" class="java" data-ke-language="java" data-ke-type="codeblock"><code>Thread-1: run()
Thread-0: run()</code></pre>
<hr contenteditable="false" data-ke-type="horizontalRule" data-ke-style="style6" />
<h2 data-ke-size="size26"><b><span style="font-family: 'Nanum Gothic'; color: #000000;">#2 implement Runnable Interface</span></b></h2>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;"><span style="background-color: #333333; color: #dddddd;">Runnable Interface</span>를 구현하여 스레드를 생성한다.</span></p>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;">Runnable Interface를 구현한 <span style="background-color: #c0d1e7;">클래스의 인스턴스를 생성한 뒤, 작업을 실행할 스레드로 인스턴스를 전달</span>한다.&nbsp;</span></p>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;">즉 <span style="background-color: #c0d1e7;">Runnable은 스레드가 실행할 작업 명세서</span>이며, <span style="background-color: #c0d1e7;">Thread는 실제로 명세서에 적힌 작업을 실행하는 주체</span>이다.&nbsp;&nbsp;</span></p>
<pre id="code_1726127621361" class="java" data-ke-language="java" data-ke-type="codeblock"><code>public class MyRunnable implements Runnable{
    @Override
    public void run() {
        System.out.println(Thread.currentThread().getName() + ": run()");
    }
}</code></pre>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;">Thread Constructor의 첫 번째 인자로 Runnable 객체를 두 번째 인자로 문자열을 전달하여 스레드의 이름을 설정해 줄 수 도 있다.</span></p>
<pre id="code_1726127602193" class="java" data-ke-language="java" data-ke-type="codeblock"><code>public class HelloRunnableMain {
    public static void main(String[] args) {

        MyRunnable runnable = new MyRunnable(); // 스레드가 실행할 작업
        Thread thread = new Thread(runnable, "NovThread"); // 작업을 스레드로 전달, 스레드 이름 설정
        thread.start(); // 작업 실행
    }
}</code></pre>
<pre id="code_1726127705758" class="java" data-ke-language="java" data-ke-type="codeblock"><code>NovThread: run()</code></pre>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size18"><b><span style="font-family: 'Nanum Gothic'; color: #000000;">스레드 이름 설정 방법</span></b></p>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;"> &bull; <b>스레드 생성 시 이름 지정</b>: new Thread(new Runnable(), "ThreadName")</span></p>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;"> &bull; <b>스레드 생성 후 이름 변경</b>: thread.setName("NewName")</span></p>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;"> &bull; <b>현재 스레드 이름 가져오기</b>: Thread.currentThread().getName()</span></p>
<hr contenteditable="false" data-ke-type="horizontalRule" data-ke-style="style6" />
<h2 data-ke-size="size26"><b><span style="font-family: 'Nanum Gothic'; color: #000000;">#3 Thread vs Runnable</span></b></h2>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;">Thread 클래스에서 제공하는 기능이 꼭 필요한 상황이 아니라면 <span style="background-color: #333333; color: #dddddd;">Runnable 인터페이스를 구현하는 방식을 권장한다.</span></span></p>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;">Runnable 인터페이스를 구현하는 방식은 <span style="background-color: #c0d1e7;">Thread의 생성부와 실행부가 분리되어 있기에, 가독성이 높아진다.</span></span></p>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;">또한 JAVA 언어 특성상 Python과 같은 언어와는 달리 다중 상속을 지원하지 않는다.</span></p>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;">따라서 <span style="background-color: #c0d1e7;">Thread 클래스를 상속받으면 다른 클래스를 더 이상 상속받지 못해 코드 유연성이 떨어진다.</span></span></p>
<pre id="code_1726128335767" class="java" data-ke-language="java" data-ke-type="codeblock"><code>public class MyThread extends Thread, AnotherThread // 불가능{
    @Override
    public void run() {
        System.out.println(Thread.currentThread().getName() + ": run()");
    }
}</code></pre>
<hr contenteditable="false" data-ke-type="horizontalRule" data-ke-style="style6" />
                        </div>
                        <br/>
                        <div class="tags">
                            
                        </div>
                    </div>
                </div>
            </div>
        </main>
    </div>
</div>
</body>
</html>
