
<meta charset="utf-8">
<html lang="ko">
<head>
    <link rel="stylesheet" type="text/css" href="./../style.css" />
    <title>[C++] range-based-for 범위 기반 for문 _ 미완성</title>
</head>
<body id="tt-body-page" class="">
<div id="wrap" class="wrap-right">
    <div id="container">
        <main class="main ">
            <div class="area-main">
                <div class="area-view">
                    <div class="article-header">
                        <div class="inner-article-header">
                            <div class="box-meta">
                                <h2 class="title-article">[C++] range-based-for 범위 기반 for문 _ 미완성</h2>
                                <div class="box-info">
                                    <p class="category">? Archive/C&C++</p>
                                    <p class="date">2022-03-17 12:12:06</p>
                                </div>
                            </div>
                        </div>
                    </div>
                    <hr>
                    <div class="article-view">
                        <div class="contents_style">
                            <p style="text-align: center;" data-ke-size="size18"><span style="color: #781b33;"><b><span style="font-family: 'Nanum Gothic';">*개인적인 공부 내용을 기록하는 용도로 작성한 글 이기에 잘못된 내용을 포함하고 있을 수 있습니다.</span></b></span></p>
<p style="text-align: center;" data-ke-size="size18">&nbsp;</p>
<p style="text-align: center;" data-ke-size="size18"><b><span style="font-family: 'Nanum Gothic'; color: #000000;"><span style="color: #781b33;">#1</span> range-based-for</span></b></p>
<p style="text-align: center;" data-ke-size="size18"><b><span style="font-family: 'Nanum Gothic'; color: #000000;"><span style="color: #781b33;">#2</span> range-based-for &amp; auto</span></b></p>
<p style="text-align: center;" data-ke-size="size18"><b><span style="font-family: 'Nanum Gothic'; color: #000000;"><span style="color: #781b33;">#3</span> range-based-for 단점</span></b></p>
<p style="text-align: center;" data-ke-size="size18"><b><span style="font-family: 'Nanum Gothic'; color: #000000;"><span style="color: #781b33;">#4</span> range-based-for &amp; reference</span></b></p>
<p style="text-align: center;" data-ke-size="size18"><b><span style="font-family: 'Nanum Gothic'; color: #000000;"><span style="color: #781b33;">#5</span> range-based-for &amp; const</span></b></p>
<hr contenteditable="false" data-ke-type="horizontalRule" data-ke-style="style5" />
<h2 data-ke-size="size26"><b><span style="font-family: 'Nanum Gothic'; color: #000000;"><span style="color: #781b33;">#1</span> range-based-for</span></b></h2>
<pre id="code_1647485827621" class="c++ arduino" data-ke-language="c++" data-ke-type="codeblock"><code>int main(void) {
	int ary[5] = {10, 20, 30, 40, 50};
	for (int i = 0 ; i &lt; 5 ; i++) {
		cout &lt;&lt; ary[i] &lt;&lt; " ";
	}
 	return 0;
}</code></pre>
<pre id="code_1647485838093" class="c++ arduino" data-ke-language="c++" data-ke-type="codeblock"><code>[출력결과] 10 20 30 40 50</code></pre>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;">for문을 이용해 배열의 원소를 모두 탐색한 간단한 코드이다. 반복문을 사용하면 간단하고 유연하게 배열의 원소에 접근할 수 있지만, 프로그래머의 실수로 인해 오류를 발생시킬 위험이 있다.</span></p>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;"><b><span style="background-color: #dddddd;">C++11</span><span>&nbsp;</span></b>부터는 이러한 단점을 보완하기 위한 보다 편리한<span>&nbsp;</span><b><span style="background-color: #dddddd;">range-based-for</span></b><span>&nbsp;</span>문법을 제공한다.</span></p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;">range-based-for의 기본 형식은 다음과 같다. 순회가능한 데이터 리스트에는 배열 뿐 만 아니라 STL의 vector, list, map.. 등이 모두 들어갈 수 있다.</span></p>
<pre id="code_1647482532487" class="c++ arduino" data-ke-language="c++" data-ke-type="codeblock"><code>for(데이터타입 변수이름 : 순회가능한 데이터 리스트) {
	...
}</code></pre>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;">range-based-for을 이용해 배열을 탐색해 보았다. 단순 for반복문을 사용하는 것 보다 안전하고 깔끔하게 배열의 원소에 접근할 수 있다.</span></p>
<pre id="code_1647482596314" class="c++ arduino" data-ke-language="c++" data-ke-type="codeblock"><code>int main(void) {
	int ary[5] = {10, 20, 30, 40, 50};
	for (int iter : ary) {
		cout &lt;&lt; iter &lt;&lt; " ";
	}
 	return 0;
}</code></pre>
<hr contenteditable="false" data-ke-type="horizontalRule" data-ke-style="style6" />
<h2 data-ke-size="size26"><b><span style="font-family: 'Nanum Gothic'; color: #000000;"><span style="color: #781b33;">#2</span> range-based-for &amp; auto</span></b></h2>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;">range-based-for문법을 사용할 때 데이터타입에 <b><span style="background-color: #dddddd;">auto키워드</span></b>를 사용해 <span style="background-color: #dddddd;">자료형을 추론</span>하게 하는 것이 이상적이다.</span></p>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;">자료형을 명확하게 알고 있는 상황이라면 크게 문제되지 않지만, 혹여나 그렇지 않다면 <span style="background-color: #dddddd;">강제 자료형 변환이 발생할 수 있기 때문</span>이다.</span></p>
<pre id="code_1647482826917" class="c++ arduino" data-ke-language="c++" data-ke-type="codeblock"><code>for(auto 변수이름 : 순회가능한 데이터리스트) {
	...
}</code></pre>
<pre id="code_1647482802404" class="c++ arduino" data-ke-language="c++" data-ke-type="codeblock"><code>int main(void) {
	int ary[5] = {10, 20, 30, 40, 50};
	for (auto iter : ary) {
		cout &lt;&lt; iter &lt;&lt; " ";
	}
 	return 0;
}</code></pre>
<hr contenteditable="false" data-ke-type="horizontalRule" data-ke-style="style6" />
<h2 data-ke-size="size26"><b><span style="font-family: 'Nanum Gothic'; color: #000000;"><span style="color: #781b33;">#3</span> range-based-for 단점</span></b></h2>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;">range-based-for은 몇 가지 단점을 가지고 있다. (물론 이를 보완할 수 있는 여러가지 방법이 있다. 이에 대해서는 바로 소개할 예정이다.)&nbsp;</span></p>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;"><span style="background-color: #dddddd;"><b>range-based-for 내부에서 요소의 값을 변경하는 것이 불가능하다.</b></span> 왜냐하면 range-based-for은 <span style="background-color: #dddddd;">요소를 복사한 값으로 취급</span>하기 때문이다.&nbsp;</span></p>
<pre id="code_1647483040393" class="c++ arduino" data-ke-language="c++" data-ke-type="codeblock"><code>int main(void) {
	int ary[5] = {10, 20, 30, 40, 50};
	for (auto iter : ary) {
		iter += 100;
	}
	for (auto iter : ary) {
		cout &lt;&lt; iter &lt;&lt; " ";
	}
 	return 0;
}</code></pre>
<pre id="code_1647483055817" class="c++ arduino" data-ke-language="c++" data-ke-type="codeblock"><code>[출력결과] 10 20 30 40 50</code></pre>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;">반면에 for문을 직접 원소에 접근하기에 배열 내부의 원소의 값을 변경할 수 있다.</span></p>
<pre id="code_1647483160927" class="c++ arduino" data-ke-language="c++" data-ke-type="codeblock"><code>int main(void) {
	int ary[5] = {10, 20, 30, 40, 50};
	for (int i = 0 ; i &lt; 5 ; i++) {
		ary[i] += 100;
	}
	for (int i = 0 ; i &lt; 5 ; i++) {
		cout &lt;&lt; ary[i] &lt;&lt; " ";
	}
 	return 0;
}</code></pre>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;">다음으로 range-based-for은 <b><span style="background-color: #dddddd;">요소를 복사된 값으로 취급하기에 for문과 달리 "복사비용"이 발생</span></b>한다. 이는 배열의 크기가 작다면 크게 문제가 되지 않겠지만, 배열의 크기가 커질 경우 loop를 할 때 마다 매번 복사비용이 발생하기에 심각한 메모리 낭비가 야기된다.</span></p>
<hr contenteditable="false" data-ke-type="horizontalRule" data-ke-style="style6" />
<h2 data-ke-size="size26"><b><span style="font-family: 'Nanum Gothic'; color: #000000;"><span style="color: #781b33;">#4</span> range-based-for &amp; reference</span></b></h2>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;">사실 앞서 설명한 단점은 C++의 <b><span style="background-color: #dddddd;">참조자(&amp;)</span></b>를 사용하면 해결 가능하다. 자료형 뒤에 &amp;키워드를 붙여주면 <span style="background-color: #dddddd;">원소에 직접 접근하기에 배열 내부 원소의 값을 변경할 수 있으며 복사 비용 또한 발생하지 않는다.</span></span></p>
<pre id="code_1647483609416" class="c++ arduino" data-ke-language="c++" data-ke-type="codeblock"><code>for (auto&amp; 변수이름 : 순회가능한 데이터리스트) {
	...
}</code></pre>
<pre id="code_1647483688169" class="c++ arduino" data-ke-language="c++" data-ke-type="codeblock"><code>int main(void) {
	int ary[5] = {10, 20, 30, 40, 50};
	for (auto&amp; iter : ary) {
		iter += 100;
	}
	for (auto&amp; iter : ary) {
		cout &lt;&lt; iter &lt;&lt; " ";
	}
 	return 0;
}</code></pre>
<pre id="code_1647483700241" class="c++ arduino" data-ke-language="c++" data-ke-type="codeblock"><code>[출력결과] 110 120 130 140 150</code></pre>
<hr contenteditable="false" data-ke-type="horizontalRule" data-ke-style="style6" />
<h2 data-ke-size="size26"><span style="font-family: 'Nanum Gothic';"><b><span style="color: #000000;"><span style="color: #781b33;">#5</span> range-based-for &amp; const</span></b></span></h2>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;"><span style="background-color: #dddddd;">배열의 원소를 변경하지 않고 탐색만 하고자 하는 경우</span>에는 <span style="background-color: #dddddd;"><b>const 키워드</b></span>를 사용하는 것이 바람직하다.</span></p>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;">자료형 앞에 const 키워드를 사용하면 <span style="background-color: #dddddd;">원래의 원소를 변경하지 못하기에 에러가 발생할 여지를 차단</span>할 수 있고, <span style="background-color: #dddddd;">참조자를 사용하기에 복사비용도 발생하지 않는다.&nbsp;</span></span></p>
<pre id="code_1647483954306" class="c++ arduino" data-ke-language="c++" data-ke-type="codeblock"><code>for (const auto&amp; iter : 순회 가능한 데이터리스트) {
	...
}</code></pre>
<pre id="code_1647484005934" class="c++ arduino" data-ke-language="c++" data-ke-type="codeblock"><code>int main(void) {
	int ary[5] = {10, 20, 30, 40, 50};
	for (const auto&amp; iter : ary) {
		cout &lt;&lt; iter &lt;&lt; " ";
	}
 	return 0;
}</code></pre>
<pre id="code_1647484016014" class="c++ arduino" data-ke-language="c++" data-ke-type="codeblock"><code>[출력결과] 10 20 30 40 50</code></pre>
<hr contenteditable="false" data-ke-type="horizontalRule" data-ke-style="style6" />
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16">#6 range-based-for &amp; initializer list</p>
                        </div>
                        <br/>
                        <div class="tags">
                            
                        </div>
                    </div>
                </div>
            </div>
        </main>
    </div>
</div>
</body>
</html>
