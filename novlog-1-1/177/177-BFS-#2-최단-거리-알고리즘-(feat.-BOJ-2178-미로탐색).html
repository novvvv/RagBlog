
<meta charset="utf-8">
<html lang="ko">
<head>
    <link rel="stylesheet" type="text/css" href="./../style.css" />
    <title>BFS #2 최단 거리 알고리즘 (feat. BOJ 2178 미로탐색)</title>
</head>
<body id="tt-body-page" class="">
<div id="wrap" class="wrap-right">
    <div id="container">
        <main class="main ">
            <div class="area-main">
                <div class="area-view">
                    <div class="article-header">
                        <div class="inner-article-header">
                            <div class="box-meta">
                                <h2 class="title-article">BFS #2 최단 거리 알고리즘 (feat. BOJ 2178 미로탐색)</h2>
                                <div class="box-info">
                                    <p class="category">? Archive/Algorithm</p>
                                    <p class="date">2022-03-02 18:18:48</p>
                                </div>
                            </div>
                        </div>
                    </div>
                    <hr>
                    <div class="article-view">
                        <div class="contents_style">
                            <p style="text-align: center;" data-ke-size="size16"><b><span style="background-color: #ffffff; color: #000000; font-family: 'Nanum Gothic';">* 개인적인 공부 내용을 기록하는 용도로 작성한 글 이기에 잘못된 내용을 포함하고 있을 수 있습니다.</span></b></p>
<p style="text-align: center;" data-ke-size="size16"><span style="color: #000000; font-family: 'Nanum Gothic';">다음 포스팅은&nbsp;<u><b>BaaaaaaaaarkingDog님의 실전 알고리즘 강좌 0x09강-BFS</b></u>&nbsp;내용을 공부한 뒤 개인적인 공부 기록 용도로 다시 정리한 글 입니다.&nbsp;</span></p>
<p style="text-align: center;" data-ke-size="size16"><span style="font-family: 'Nanum Gothic';"><span style="color: #000000;">내용 출처 :</span>&nbsp;<a href="https://blog.encrypted.gg/941?category=773649">BaaaaaaaarkingDog | [실전 알고리즘] 0x09강 - BFS (encrypted.gg)</a></span></p>
<figure id="og_1646212786154" contenteditable="false" data-ke-type="opengraph" data-ke-align="alignCenter" data-og-type="article" data-og-title="[실전 알고리즘] 0x09강 - BFS" data-og-description="안녕하세요 여러분, 드디어 올 것이 왔습니다. 마음의 준비를 단단히 하셔야 합니다.. 드디어 실전 알고리즘 강의에서 첫 번째 고비에 도달했는데&nbsp;이 강의와 함께 이번 고비를 잘 헤쳐나가면 좋" data-og-host="blog.encrypted.gg" data-og-source-url="https://blog.encrypted.gg/941?category=773649" data-og-url="https://blog.encrypted.gg/941" data-og-image="https://scrap.kakaocdn.net/dn/hnIT9/hyNA1h8yqp/RRguOjkGMeiaDCAKpi4lSk/img.png?width=800&amp;height=450&amp;face=0_0_800_450,https://scrap.kakaocdn.net/dn/dNmJL7/hyNzYm2y04/YnwPE3bm3Z1B3MnfSNPeb1/img.png?width=800&amp;height=450&amp;face=0_0_800_450"><a href="https://blog.encrypted.gg/941?category=773649" target="_blank" rel="noopener" data-source-url="https://blog.encrypted.gg/941?category=773649">
<div class="og-image" style="background-image: url('https://scrap.kakaocdn.net/dn/hnIT9/hyNA1h8yqp/RRguOjkGMeiaDCAKpi4lSk/img.png?width=800&amp;height=450&amp;face=0_0_800_450,https://scrap.kakaocdn.net/dn/dNmJL7/hyNzYm2y04/YnwPE3bm3Z1B3MnfSNPeb1/img.png?width=800&amp;height=450&amp;face=0_0_800_450');">&nbsp;</div>
<div class="og-text">
<p class="og-title" data-ke-size="size16">[실전 알고리즘] 0x09강 - BFS</p>
<p class="og-desc" data-ke-size="size16">안녕하세요 여러분, 드디어 올 것이 왔습니다. 마음의 준비를 단단히 하셔야 합니다.. 드디어 실전 알고리즘 강의에서 첫 번째 고비에 도달했는데&nbsp;이 강의와 함께 이번 고비를 잘 헤쳐나가면 좋</p>
<p class="og-host" data-ke-size="size16">blog.encrypted.gg</p>
</div>
</a></figure>
<p style="text-align: center;" data-ke-size="size16"><span style="background-color: #ffffff; color: #000000; font-family: 'Nanum Gothic';"><b>문제 출처 :</b> <a href="https://www.acmicpc.net/problem/2178">2178번: 미로 탐색 (acmicpc.net)</a></span></p>
<figure id="og_1646212595054" contenteditable="false" data-ke-type="opengraph" data-ke-align="alignCenter" data-og-type="website" data-og-title="2178번: 미로 탐색" data-og-description="첫째 줄에 두 정수 N, M(2 &le; N, M &le; 100)이 주어진다. 다음 N개의 줄에는 M개의 정수로 미로가 주어진다. 각각의 수들은 붙어서 입력으로 주어진다." data-og-host="www.acmicpc.net" data-og-source-url="https://www.acmicpc.net/problem/2178" data-og-url="https://www.acmicpc.net/problem/2178" data-og-image="https://scrap.kakaocdn.net/dn/HNOGN/hyNzVKMb41/JlenlSXKMyJxmAxmKTmRUK/img.png?width=1200&amp;height=630&amp;face=0_0_1200_630"><a href="https://www.acmicpc.net/problem/2178" target="_blank" rel="noopener" data-source-url="https://www.acmicpc.net/problem/2178">
<div class="og-image" style="background-image: url('https://scrap.kakaocdn.net/dn/HNOGN/hyNzVKMb41/JlenlSXKMyJxmAxmKTmRUK/img.png?width=1200&amp;height=630&amp;face=0_0_1200_630');">&nbsp;</div>
<div class="og-text">
<p class="og-title" data-ke-size="size16">2178번: 미로 탐색</p>
<p class="og-desc" data-ke-size="size16">첫째 줄에 두 정수 N, M(2 &le; N, M &le; 100)이 주어진다. 다음 N개의 줄에는 M개의 정수로 미로가 주어진다. 각각의 수들은 붙어서 입력으로 주어진다.</p>
<p class="og-host" data-ke-size="size16">www.acmicpc.net</p>
</div>
</a></figure>
<hr contenteditable="false" data-ke-type="horizontalRule" data-ke-style="style5" />
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;">BOJ 2178 미로탐색 문제는 BFS의 최단 거리 알고리즘을 이용해 풀이할 수 있다.</span></p>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;">문제는 간단하다 좌측 상단 시작점 (0, 0) 에서 우측 하단 (N, M) 까지 가는 길 중 최단 거리로 가는 방법을 구하는 문제이다.</span></p>
<p><figure class="imageblock alignLeft" >
    <span data-lightbox="lightbox">
        <img src="./img/img.png"  />
    </span>
    <figcaption></figcaption>
</figure><figure class="imageblock alignLeft" >
    <span data-lightbox="lightbox">
        <img src="./img/img_1.png"  />
    </span>
    <figcaption></figcaption>
</figure></p>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;">BFS의 기본 개념에서 살짝만 응용하면 간단하게 해결 가능하다.</span></p>
<p data-ke-size="size16"><b><span style="font-family: 'Nanum Gothic'; color: #000000;">[BFS 구현] _ <a href="https://novlog.tistory.com/174?category=860654" target="_blank" rel="noopener">LINK</a></span></b></p>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;"><span style="color: #0593d3;"><b><span>1. 시작하는 칸을 큐에 넣고 방문 표시를 남긴다.</span></b></span></span></p>
<p data-ke-size="size16"><span style="color: #0593d3;"><b><span>2. 큐에서 원소를 꺼내어 해당하는 칸의 상화좌우로 인접한 칸에 대하여 3번을 진행한다.</span></b></span></p>
<p data-ke-size="size16"><span style="color: #0593d3;"><b><span>3. 해당 칸을 이전에 방문했다면 아무 것도 수행하지 않고, 처음 방문 했다면 방문 표시를 남기고 해당 칸을 큐에 삽입한다.</span></b></span></p>
<p data-ke-size="size16"><span style="color: #0593d3;"><b><span>4. 큐가 빌 때 까지 2번을 반복한다.</span></b></span></p>
<p data-ke-size="size16"><span style="color: #0593d3;"><b><span>모든 칸이 큐에 한 번씩 들어가게 되기에 시간 복잡도는 칸이 N개 일때 O(N)이다.</span></b></span></p>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;">보드의 정보를 저장하는 board 배열 방문 여부를 저장하는 vis 배열 외에, <span style="background-color: #333333; color: #ffffff;">각 칸의 거리를 저장하는 dis 배</span>열을 추가적으로 선언하여 칸마다 거리를 저장해 주면 된다.</span></p>
<p><figure class="imageblock alignLeft" >
    <span data-lightbox="lightbox">
        <img src="./img/img_2.png"  />
    </span>
    <figcaption></figcaption>
</figure></p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;"><span style="background-color: #333333; color: #ffffff;">cur(커서)가 가리키는 칸의 값에서 1을 더해주면 다음 칸의 거리를 구할 수 있다.</span> 예를들어 현재 커서가 12를 가리키고 있다면 상하좌우를 탐색할 것이다.</span></p>
<p><figure class="imageblock alignLeft" >
    <span data-lightbox="lightbox">
        <img src="./img/img_3.png"  />
    </span>
    <figcaption></figcaption>
</figure></p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;">이때 좌측은 유효하지 않은 칸 (board[nx][ny] != '1') 이고, 위측은 이미 지나온 칸 (vis[nx][ny] != 0) 이므로 continue 한다.</span></p>
<p><figure class="imageblock alignLeft" >
    <span data-lightbox="lightbox">
        <img src="./img/img_4.png"  />
    </span>
    <figcaption></figcaption>
</figure></p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;">다음으로 우측과 아래쪽은 유효한 칸 이므로 커서가 가리키는 칸의 값 (12) 에 1을 더해서 13으로 초기화 해 준다.</span></p>
<p><figure class="imageblock alignLeft" >
    <span data-lightbox="lightbox">
        <img src="./img/img_5.png"  />
    </span>
    <figcaption></figcaption>
</figure></p>
<pre id="code_1646212135469" class="c++ arduino" data-ke-language="c++" data-ke-type="codeblock"><code>	while (!Q.empty()) {
		pair&lt;int,int&gt; cur;
		cur = Q.front(); Q.pop();
		for (int dir = 0; dir &lt; 4; dir++) {
			int nx = cur.X + dx[dir];
			int ny = cur.Y + dy[dir];
			if (nx &lt; 0 || nx &gt;= n || ny &lt; 0 || ny &gt;= m) { continue; } // 범위 밖일 경우 넘어간다.
			if (vis[nx][ny] || board[nx][ny] != '1') { continue; } // 이미 방문한 칸이거나, 유효 칸이 아닌 경우 넘어간다.
			vis[nx][ny] = 1; // 방문 표시
			dis[nx][ny] = dis[cur.X][cur.Y] + 1; // 커서가 가리키는 칸에서 + 1
			Q.push({nx,ny}); // 큐에 푸시
		}</code></pre>
<p data-ke-size="size16">&nbsp;</p>
<h2 data-ke-size="size26"><b><span style="font-family: 'Nanum Gothic';">#CODE</span></b></h2>
<pre id="code_1646212428723" class="c++ arduino" data-ke-language="c++" data-ke-type="codeblock"><code>#include &lt;bits/stdc++.h&gt;
using namespace std;
#define X first
#define Y second
string board[502];
bool vis[502][502];
int dis[502][502];
int dx[4] = {1, 0, -1, 0};
int dy[4] = {0, 1, 0, -1};
int main() {
	ios::sync_with_stdio(0);
	cin.tie(0);
	int n, m;
	cin &gt;&gt; n &gt;&gt; m;
	for (int i = 0; i &lt; n; i++) {
		cin &gt;&gt; board[i];
	}
	
	// 시작하는 칸을 큐에 넣고 방문 표시를 한다.
	queue&lt;pair&lt;int,int&gt;&gt; Q;
	Q.push({0, 0});
	vis[0][0] = 1;
	dis[0][0] = 0;
	
	while (!Q.empty()) {
		pair&lt;int,int&gt; cur;
		cur = Q.front(); Q.pop();
		for (int dir = 0; dir &lt; 4; dir++) {
			int nx = cur.X + dx[dir];
			int ny = cur.Y + dy[dir];
			if (nx &lt; 0 || nx &gt;= n || ny &lt; 0 || ny &gt;= m) { continue; } // 범위 밖일 경우 넘어간다.
			if (vis[nx][ny] || board[nx][ny] != '1') { continue; } // 이미 방문한 칸이거나, 유효 칸이 아닌 경우 넘어간다.
			vis[nx][ny] = 1; // 방문 표시
			dis[nx][ny] = dis[cur.X][cur.Y] + 1; // 커서가 가리키는 칸에서 + 1
			Q.push({nx,ny}); // 큐에 푸시
		}
	}
	
	// for (int i = 0; i &lt; n; i++) {
	// 	for (int j = 0; j &lt; m; j++) {
	// 		cout &lt;&lt; dis[i][j];
	// 	}
	// 	cout &lt;&lt; '\n';
	// }
	
	cout &lt;&lt; dis[n-1][m-1] + 1;
	return 0;
}</code></pre>
                        </div>
                        <br/>
                        <div class="tags">
                            #소스코드 #문제풀이 #백준 #BFS #미로탐색 #2178 #최단거리알고리즘 
                        </div>
                    </div>
                </div>
            </div>
        </main>
    </div>
</div>
</body>
</html>
