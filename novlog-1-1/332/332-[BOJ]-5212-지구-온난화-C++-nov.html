
<meta charset="utf-8">
<html lang="ko">
<head>
    <link rel="stylesheet" type="text/css" href="./../style.css" />
    <title>[BOJ] 5212 지구 온난화 C++ nov</title>
</head>
<body id="tt-body-page" class="">
<div id="wrap" class="wrap-right">
    <div id="container">
        <main class="main ">
            <div class="area-main">
                <div class="area-view">
                    <div class="article-header">
                        <div class="inner-article-header">
                            <div class="box-meta">
                                <h2 class="title-article">[BOJ] 5212 지구 온난화 C++ nov</h2>
                                <div class="box-info">
                                    <p class="category">Problem Solving/BOJ</p>
                                    <p class="date">2024-11-24 16:41:29</p>
                                </div>
                            </div>
                        </div>
                    </div>
                    <hr>
                    <div class="article-view">
                        <div class="contents_style">
                            <h2 data-ke-size="size26"><b><span style="font-family: 'Nanum Gothic'; color: #000000;">#INFO</span></b></h2>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;">알고리즘 유형 : <span style="background-color: #c0d1e7;">시뮬레이션 &amp; 구현</span></span></p>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;">난이도 : <span style="background-color: #dddddd;">SILVER2</span></span></p>
<p><figure class="imageblock alignLeft" >
    <span data-lightbox="lightbox">
        <img src="./img/img.png"  />
    </span>
    <figcaption></figcaption>
</figure><figure class="imageblock alignLeft" >
    <span data-lightbox="lightbox">
        <img src="./img/img_1.png"  />
    </span>
    <figcaption></figcaption>
</figure></p>
<p data-ke-size="size16">&nbsp;</p>
<h2 data-ke-size="size26"><b><span style="font-family: 'Nanum Gothic'; color: #000000;">#SOLVE</span></b></h2>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;">현재 지도의 모습을 기준으로 50년 뒤의 지도의 모양을 출력하는 구현 문제이다.&nbsp;</span></p>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;">우선 2차원 배열을 선언한 뒤 현재 지도의 모습을 배열에 저장한다. "."으로 표시된 부분은 "바다"이며, "X"로 표시된 부분은 "섬"이다.</span></p>
<pre id="code_1732432890319" class="cpp" data-ke-language="cpp" data-ke-type="codeblock"><code>    // #1 Input &amp; init Value
    vector&lt;vector&lt;char&gt;&gt; board;
    int R, C;
    cin &gt;&gt; R &gt;&gt; C;
    for (int i = 0; i &lt; R; i++) {
        vector&lt;char&gt; line(C);
        for (int j = 0; j &lt; C; j++) {
            cin &gt;&gt; line[j];
        }
        board.push_back(line);
    }</code></pre>
<p><figure class="imageblock alignLeft" width="587" height="213" >
    <span data-lightbox="lightbox">
        <img src="./img/img_2.png" width="587" height="213"  />
    </span>
    <figcaption></figcaption>
</figure></p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;">문제 조건에 의하면 현재 섬을 기준으로 인접한 세 칸 혹은 네 칸이 바다(".")가 있는 땅은 50년 이후에 바다로 변한다.</span></p>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;">예시로 아래 보라색 땅은 세 면이 바다로 둘러싸여 있기에 바다로 변하지만 빨간색 땅은 두 면이 바다로 둘러 싸여져 있기에 바다로 변하지 않는다.</span></p>
<p><figure class="imageblock alignLeft" width="588" height="212" >
    <span data-lightbox="lightbox">
        <img src="./img/img_3.png" width="588" height="212"  />
    </span>
    <figcaption></figcaption>
</figure></p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;">또한 지도를 벗어나는 범위도 모두 바다로 판별하기에, 좌측 하단의 땅과 같은 케이스 또한 50년 뒤에 바다로 변한다.</span></p>
<p><figure class="imageblock alignLeft" width="584" height="217" >
    <span data-lightbox="lightbox">
        <img src="./img/img_4.png" width="584" height="217"  />
    </span>
    <figcaption></figcaption>
</figure></p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;">50년 뒤 지도의 모습을 저장할 bool type 2차원 벡터를 선언한다.&nbsp;</span></p>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;">기존 board에 바로 정보를 업데이트하면 다음 땅의 정보를 계상할때 영향이 가기에 별도로 벡터를 선언하였다.</span></p>
<pre id="code_1732433177439" class="cpp" data-ke-language="cpp" data-ke-type="codeblock"><code>    // check_board : 50년 뒤 땅의 예상 모습을 저장하는 벡터
    // * 바로 board에 정보를 업데이트하면 계산에 영항이 가기에 별도의 bool 벡터를 선언한다.
    // false : 바다 , true : 섬
    vector&lt;vector&lt;bool&gt;&gt; check_board(R, vector&lt;bool&gt;(C, false));
    for (int i = 0; i &lt; R; i++) {
        for (int j = 0; j &lt; C; j++) {
            if (board[i][j] == 'X') check_board[i][j] = true;
        }
    }</code></pre>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;">기존 board에 저장된 지도 정보를 기준으로 check_board를 업데이트한다.&nbsp;</span></p>
<pre id="code_1732433289791" class="cpp" data-ke-language="cpp" data-ke-type="codeblock"><code>    // 인접한 바다의 영역을 기준으로 check_board를 업데이트
    for (int i = 0; i &lt; board.size(); i++) {
        for (int j = 0; j &lt; board[i].size(); j++) {
            int check = 0;
            if (board[i][j] == 'X') {
                if (i - 1 &gt;= 0) {
                    if (board[i-1][j] == '.') check++;
                }
                if (i + 1 &lt; board.size()) {
                    if (board[i+1][j] == '.') check++;
                }
                if (j - 1 &gt;= 0) {
                    if (board[i][j-1] == '.') check++;
                }
                if (j + 1 &lt; board[i].size()) {
                    if (board[i][j+1] == '.') check++;
                }

                // 배열의 범위를 벗어난 경우 -&gt; 바다로 판정
                if (i -1 &lt; 0) check++;
                if (i + 1 &gt;= board.size()) check++;
                if (j - 1 &lt; 0) check++;
                if (j + 1 &gt;= board[i].size()) check++;

                if (check &gt;= 3) {
                    check_board[i][j] = false;
                }

            }
        }
    }</code></pre>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;">다음으로 check_board 벡터에 저장된 정보를 기반으로 기존 Board에 50년 뒤의 지도의 모습을 업데이트한다.</span></p>
<pre id="code_1732433402038" class="cpp" data-ke-language="cpp" data-ke-type="codeblock"><code>    // Check_board를 기준으로 기존 board를 업데이트
    for (int i = 0; i &lt; board.size(); i++) {
        for (int j = 0; j &lt; board[i].size(); j++) {
            if (check_board[i][j] == false) board[i][j] = '.';
            else board[i][j] = 'X';
        }
    }</code></pre>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;">마지막으로 업데이트된 board 배열을 모든 섬을 포함하는 가장 작은 직사각형이 되도록 잘라 주어야 한다.&nbsp;</span></p>
<p data-ke-size="size16"><span style="font-family: 'Nanum Gothic'; color: #000000;">아이디어는 간단하다. board에 저장된 모든 정보를 루프를 돌며 가장 큰 column, row 값과 가장 작은 column, row 값을 저장한 뒤 해당하는 범위에 있는 정보만을 출력하도록 하였다.&nbsp;</span></p>
<p><figure class="imageblock alignLeft" width="764" height="288" >
    <span data-lightbox="lightbox">
        <img src="./img/img_5.png" width="764" height="288"  />
    </span>
    <figcaption></figcaption>
</figure><figure class="imageblock alignLeft" width="700" height="259" >
    <span data-lightbox="lightbox">
        <img src="./img/img_6.png" width="700" height="259"  />
    </span>
    <figcaption></figcaption>
</figure></p>
<pre id="code_1732433958815" class="cpp" data-ke-language="cpp" data-ke-type="codeblock"><code>    // 지도를 자를 범위를 설정
    int min_column = 99, max_column = -1, min_row = 99, max_row = -1;
    for (int i = 0; i &lt; board.size(); i++) {
        for (int j = 0; j &lt; board[i].size(); j++) {
            if (board[i][j] == 'X') {
                if (min_column &gt; i) min_column = i;
                if (max_column &lt; i) max_column = i;
                if (min_row &gt; j) min_row = j;
                if (max_row &lt; j) max_row = j;
            }
        }
    }

    // Output
    for (int i = min_column; i &lt;= max_column; i++) {
        for (int j = min_row; j &lt;= max_row; j++) {
            cout &lt;&lt; board[i][j];
        }
        cout &lt;&lt; endl;
    }</code></pre>
<p data-ke-size="size16">&nbsp;</p>
<h2 data-ke-size="size26"><b><span style="font-family: 'Nanum Gothic'; color: #000000;">#CODE</span></b></h2>
<p data-ke-size="size18"><b><span style="font-family: 'Nanum Gothic'; color: #000000;">C++</span></b></p>
<pre id="code_1732433988766" class="cpp" data-ke-language="cpp" data-ke-type="codeblock"><code>/////////////////////////////////////////////////////////////////////
/** Info
 * developer : nov
 * BOJ 5212 지구온난화
 * 제출일자 : 2024.11.24(일)
 * ver : 1.0
**/
/////////////////////////////////////////////////////////////////////

#include &lt;iostream&gt;
#include &lt;vector&gt;
using namespace std;

int main() {

    ios::sync_with_stdio(0);
    cin.tie(0);

    // #1 Input &amp; init Value
    vector&lt;vector&lt;char&gt;&gt; board;
    int R, C;
    cin &gt;&gt; R &gt;&gt; C;
    for (int i = 0; i &lt; R; i++) {
        vector&lt;char&gt; line(C);
        for (int j = 0; j &lt; C; j++) {
            cin &gt;&gt; line[j];
        }
        board.push_back(line);
    }

    // check_board : 50년 뒤 땅의 예상 모습을 저장하는 벡터
    // * 바로 board에 정보를 업데이트하면 계산에 영항이 가기에 별도의 bool 벡터를 선언한다.
    // false : 바다 , true : 섬
    vector&lt;vector&lt;bool&gt;&gt; check_board(R, vector&lt;bool&gt;(C, false));
    for (int i = 0; i &lt; R; i++) {
        for (int j = 0; j &lt; C; j++) {
            if (board[i][j] == 'X') check_board[i][j] = true;
        }
    }

    // 인접한 바다의 영역을 기준으로 check_board를 업데이트
    for (int i = 0; i &lt; board.size(); i++) {
        for (int j = 0; j &lt; board[i].size(); j++) {
            int check = 0;
            if (board[i][j] == 'X') {
                if (i - 1 &gt;= 0) {
                    if (board[i-1][j] == '.') check++;
                }
                if (i + 1 &lt; board.size()) {
                    if (board[i+1][j] == '.') check++;
                }
                if (j - 1 &gt;= 0) {
                    if (board[i][j-1] == '.') check++;
                }
                if (j + 1 &lt; board[i].size()) {
                    if (board[i][j+1] == '.') check++;
                }

                // 배열의 범위를 벗어난 경우 -&gt; 바다로 판정
                if (i -1 &lt; 0) check++;
                if (i + 1 &gt;= board.size()) check++;
                if (j - 1 &lt; 0) check++;
                if (j + 1 &gt;= board[i].size()) check++;

                if (check &gt;= 3) {
                    check_board[i][j] = false;
                }

            }
        }
    }

    // Check_board를 기준으로 기존 board를 업데이트
    for (int i = 0; i &lt; board.size(); i++) {
        for (int j = 0; j &lt; board[i].size(); j++) {
            if (check_board[i][j] == false) board[i][j] = '.';
            else board[i][j] = 'X';
        }
    }


    // 지도를 자를 범위를 설정
    int min_column = 99, max_column = -1, min_row = 99, max_row = -1;
    for (int i = 0; i &lt; board.size(); i++) {
        for (int j = 0; j &lt; board[i].size(); j++) {
            if (board[i][j] == 'X') {
                if (min_column &gt; i) min_column = i;
                if (max_column &lt; i) max_column = i;
                if (min_row &gt; j) min_row = j;
                if (max_row &lt; j) max_row = j;
            }
        }
    }

    // Output
    for (int i = min_column; i &lt;= max_column; i++) {
        for (int j = min_row; j &lt;= max_row; j++) {
            cout &lt;&lt; board[i][j];
        }
        cout &lt;&lt; endl;
    }


    return 0;
}</code></pre>
                        </div>
                        <br/>
                        <div class="tags">
                            #오블완 #티스토리챌린지 
                        </div>
                    </div>
                </div>
            </div>
        </main>
    </div>
</div>
</body>
</html>
